<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <!--
      Copyright (c) 2006-2011 Krell Institute. All Rights Reserved.
      Permission is granted to copy, distribute and/or modify this document
      under the terms of the GNU Free Documentation License, Version 1.2
      or any later version published by the Free Software Foundation;
      with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
         Texts.  A copy of the license is included in the section entitled "GNU
      Free Documentation License".
-->
    <meta content="text/html; charset=ISO-8859-1"
      http-equiv="content-type">
    <title>HowToCreatePluginsForOpenSpeedShop</title>
  </head>
  <body>
    <p style="text-align: center;"><span class="mozTocH1"></span><br>
    </p>
    <p style="text-align: center;"><br>
      <img alt="Open|SpeedShop logo" src="OpenSpeedShop_Logo.jpg"
        style="width: 303px; height: 38px;"><br>
      <big><big style="font-weight: bold;"><big>Plugin Creation Guide</big></big></big></p>
    <div style="text-align: center;"><big><span style="font-weight:
          bold;">Version 2.0.2 Release</span><br style="font-weight:
          bold;">
        <span style="font-weight: bold;">November 9, 2012<br>
          (NOTE: concepts are still valid but some diagrams need
          updating)<br>
        </span></big></div>
    <br>
    <h1><a class="mozTocH1" name="mozTocId977725"></a><span
        class="mozTocH2"></span><small><a name="Top"></a>Table of
        Contents</small><span style="text-decoration: underline;"></span></h1>
    <ul id="mozToc">
      <!--mozToc h1 1 h2 2 h3 3 h4 4 h5 5 h6 6-->
      <li><a href="#mozTocId977725">Table of Contents</a>
        <ul>
          <li><a href="#mozTocId462188">Open|SpeedShop Overview and
              Information Resources</a>
            <ul>
              <li><a href="#mozTocId507487">Features:</a></li>
              <li><a href="#mozTocId88877">Open|SpeedShop Component
                  Diagram</a>
                <ul>
                  <li><a href="#mozTocId74182">Host/Client Component
                      Diagram </a></li>
                  <li><a href="#mozTocId377936">Runtime/Server Component
                      Diagram</a></li>
                </ul>
              </li>
              <li><a href="#mozTocId251693">Information Resources:</a></li>
            </ul>
          </li>
          <li><a href="#mozTocId351566">General Plugin Definition</a></li>
          <li><a href="#mozTocId11413">Open|SpeedShop Plugin Overview </a>
            <ul>
              <li><a href="#mozTocId1962">Plugin Creation Creation Notes</a></li>
              <li><a href="#mozTocId405706">Plugin Creation Outline</a>
                <ul>
                  <li><a href="#mozTocId513127">General Open|SpeedShop
                      Plugin Outline</a></li>
                  <li><a href="#mozTocId225587">General Plugin Structure</a>
                    <ul>
                      <li><a href="#mozTocId64311">Performance Data
                          Collector Plugin Structure</a></li>
                      <li><a href="#mozTocId300839">GUI Plugin Structure
                        </a></li>
                      <li><a href="#mozTocId337518">Interactive CLI
                          Plugin Structure</a></li>
                    </ul>
                  </li>
                  <li><a href="#mozTocId743777">How do plugins get
                      recognized?</a></li>
                  <li><a href="#mozTocId679293">Where are the plugins
                      located?</a></li>
                </ul>
              </li>
            </ul>
          </li>
          <li><a href="#mozTocId732797">Performance Data Collector
              Plugin Information</a>
            <ul>
              <li><a href="#mozTocId892980">Performance Data Collector
                  Quick Overview </a>
                <ul>
                  <li><a href="#mozTocId952547">Performance Data
                      Collector Plugin Outline</a></li>
                  <li><a href="#mozTocId636342">Performance Data
                      Collector Plugin Structure</a></li>
                </ul>
              </li>
              <li><a href="#mozTocId661443">Identifying and Analyzing
                  The Performance Data Desired</a></li>
              <li><a href="#mozTocId904911">Implementing The Collector
                  Plugin</a>
                <ul>
                  <li><a href="#mozTocId773274">Overview</a></li>
                  <li><a href="#mozTocId223455">Plugin Recognition</a></li>
                  <li><a href="#mozTocId207808">Data blobs</a>
                    <ul>
                      <li><a href="#mozTocId281427">blobs.x:</a></li>
                      <li><a href="#mozTocId57477">blobs.h:</a></li>
                      <li><a href="#mozTocId839482">blobs.c:</a></li>
                    </ul>
                  </li>
                  <li><a href="#mozTocId667687">Collector Runtime -
                      Server/Victim portion of Experiment Collector </a>
                    <ul>
                      <li><a href="#mozTocId612900">Thread Specific Data</a></li>
                      <li><a href="#mozTocId973451">Timer event handler</a></li>
                      <li><a href="#mozTocId10166">Start Sampling</a></li>
                      <li><a href="#mozTocId999542">Stop Sampling</a></li>
                      <li><a href="#mozTocId40824">Framework runtime</a></li>
                    </ul>
                  </li>
                  <li><a href="#mozTocId637965">Collector Plugin -
                      Client/Tool portion of Experiment Collector </a></li>
                  <li><a href="#mozTocId775061">Collector Plugin API-
                      Public Member Functions </a>
                    <ul>
                      <li><a href="#mozTocId388988">The Start Collecting
                          function </a>
                        <ul>
                          <li><a href="#mozTocId199690">What it does:</a></li>
                          <li><a href="#mozTocId219262">Definition:</a></li>
                          <li><a href="#mozTocId347609">Parameters:</a></li>
                          <li><a href="#mozTocId50896">What's needed in
                              the function body:</a></li>
                          <li><a href="#mozTocId628096">Example
                              Collector Code Example: </a></li>
                        </ul>
                      </li>
                      <li><a href="#mozTocId992246">The Stop Collecting
                          function </a>
                        <ul>
                          <li><a href="#mozTocId150755">What it does:</a></li>
                          <li><a href="#mozTocId352197">Definition:</a></li>
                          <li><a href="#mozTocId139139">Parameters:</a></li>
                          <li><a href="#mozTocId722160">Decisions and
                              what's needed in the function body:</a></li>
                          <li><a href="#mozTocId499496">Example
                              collector code example:</a></li>
                        </ul>
                      </li>
                      <li><a href="#mozTocId278716">The Get Metric
                          Values function </a>
                        <ul>
                          <li><a href="#mozTocId110227">What it does:</a></li>
                          <li><a href="#mozTocId171646">Definition:</a></li>
                          <li><a href="#mozTocId530275">Parameters:</a></li>
                          <li><a href="#mozTocId673416">Decisions and
                              what's needed in the function body:</a></li>
                          <li><a href="#mozTocId435581">Example
                              collector code example:</a></li>
                        </ul>
                      </li>
                      <li><a href="#mozTocId271962">The Set Parameter
                          function </a>
                        <ul>
                          <li><a href="#mozTocId753822">What it does:</a></li>
                          <li><a href="#mozTocId163320">Definition: </a></li>
                          <li><a href="#mozTocId699056"> Parameters:</a></li>
                          <li><a href="#mozTocId97265"> Return values:</a></li>
                          <li><a href="#mozTocId259611">Decisions and
                              what's needed in the function body:</a></li>
                          <li><a href="#mozTocId999507">Example
                              collector code example:</a></li>
                        </ul>
                      </li>
                      <li><a href="#mozTocId518369">The Get Default
                          Parameters function </a>
                        <ul>
                          <li><a href="#mozTocId709984">What it does:</a></li>
                          <li><a href="#mozTocId832976">Definition:</a></li>
                          <li><a href="#mozTocId646706">Return values:</a></li>
                          <li><a href="#mozTocId15384">Decisions and
                              what's needed in the function body:</a></li>
                          <li><a href="#mozTocId207187">Example
                              collector code example:</a></li>
                        </ul>
                      </li>
                      <li><a href="#mozTocId769605">The Get Parameters
                          function </a>
                        <ul>
                          <li><a href="#mozTocId340210">What it does:</a></li>
                          <li><a href="#mozTocId552888">Definition:</a></li>
                          <li><a href="#mozTocId731991">Parameters:</a></li>
                          <li><a href="#mozTocId705614">Return values:</a></li>
                          <li><a href="#mozTocId196328">Decisions and
                              what's needed in the function body:</a></li>
                          <li><a href="#mozTocId334143">Example
                              collector code example:</a></li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                  <li><a href="#mozTocId761089">Collector Plugin API -
                      Protected Member Functions</a>
                    <ul>
                      <li><a href="#mozTocId237373">Collector
                          Implementation Constructor</a>
                        <ul>
                          <li><a href="#mozTocId876077">Definition</a></li>
                          <li><a href="#mozTocId610118">What it does,
                              when it can be used, and example usage
                              code</a></li>
                        </ul>
                      </li>
                      <li><a href="#mozTocId778216">Declare a Parameter</a>
                        <ul>
                          <li><a href="#mozTocId399016">Definition</a></li>
                          <li><a href="#mozTocId654759">What it does,
                              when it can be used, and example usage
                              code</a></li>
                          <li><a href="#mozTocId373057">Parameters</a></li>
                          <li><a href="#mozTocId722064">Return Values</a></li>
                        </ul>
                      </li>
                      <li><a href="#mozTocId957175">Declare a Metric</a>
                        <ul>
                          <li><a href="#mozTocId684094">Definition</a></li>
                          <li><a href="#mozTocId626761">What it does,
                              when it can be used, and example usage
                              code </a></li>
                          <li><a href="#mozTocId741847">Parameters</a></li>
                          <li><a href="#mozTocId804375">Return Values</a></li>
                        </ul>
                      </li>
                      <li><a href="#mozTocId501955">Get experiment,
                          collector, and thread (ECT) identifiers</a></li>
                      <li><a href="#mozTocId858260">Execute library
                          function now.</a></li>
                      <li><a href="#mozTocId657026">Execute library
                          function at another function's entry.</a></li>
                      <li><a href="#mozTocId194372">Execute library
                          function at another function's exit.</a></li>
                      <li><a href="#mozTocId197213"> Execute a library
                          function in place of another function.</a></li>
                      <li><a href="#mozTocId342846">Remove
                          instrumentation from a thread</a></li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li><a href="#mozTocId846999">Example Collector Plugin</a></li>
              <li><a href="#mozTocId377373">Collector Plugin FAQ: </a>
                <ul>
                  <li><a href="#mozTocId198444">What is blob.x for? What
                      is the significance of the .x suffix? </a></li>
                  <li><a href="#mozTocId189119">What is specifically
                      needed to be known by the framework? Do these
                      class structures need to follow a particular
                      convention?</a></li>
                </ul>
              </li>
            </ul>
          </li>
          <li><a href="#mozTocId212847">Graphical User Interface Plugin
              Information </a>
            <ul>
              <li><a href="#mozTocId347900">Graphical User Interface
                  (GUI) Plugin Overview </a>
                <ul>
                  <li><a href="#mozTocId962438">GUI Plugin Outline</a></li>
                  <li><a href="#mozTocId117100">GUI Plugin Recognition</a></li>
                </ul>
              </li>
              <li><a href="#mozTocId930728">Creating A Graphical User
                  Interface Panel</a>
                <ul>
                  <li><a href="#mozTocId570308">Initial Skeletal Panel
                      Creation - mknewpanel script</a></li>
                  <li><a href="#mozTocId921745">The Panel Class</a></li>
                  <li><a href="#mozTocId500145">Example Sections of Code</a>
                    <ul>
                      <li><a href="#mozTocId66382">QtClass</a></li>
                      <li><a href="#mozTocId14581">TopLevel</a></li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li><a href="#mozTocId1902">Interfacing With
                  Open|SpeedShop - Tips and Example Information</a>
                <ul>
                  <li><a href="#mozTocId784520">Executing a command
                      through Command Line Interface (CLI)</a></li>
                  <li><a href="#mozTocId803177">Communicating with other
                      GUI panels</a></li>
                  <li><a href="#mozTocId525403">Managing process control</a></li>
                </ul>
              </li>
              <li><a href="#mozTocId175785">Example Graphical User
                  Interface Plugin</a></li>
            </ul>
          </li>
          <li><a href="#mozTocId90403">Interactive Command Line
              Interface Plugin Information</a>
            <ul>
              <li><a href="#mozTocId192580">Interactive Command Line
                  Interface (CLI) Plugin Overview</a>
                <ul>
                  <li><a href="#mozTocId138060">Interactive Command Line
                      Interface (CLI) Plugin Outline</a></li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
    <h2><a class="mozTocH2" name="mozTocId462188"></a><span
        class="mozTocH2"></span>Open|SpeedShop Overview and Information
      Resources</h2>
    Open|SpeedShop is a project co-funded by the Department of Energy
    (DOE), managed by the Tri-laboratories of LLNL, LANL, and Sandia,
    and developed by SGI.&nbsp; Open|SpeedShop utilizes dynamic
    instrumentation technology developed at the Universities of
    Wisconsin and Maryland. <br>
    <br>
    Open|SpeedShop is an open source multi platform Linux performance
    tool which is initially targeted to support performance analysis of
    applications running on both single node and large scale IA64, IA32,
    EM64T, and AMD64 platforms. It is explicitly designed with usability
    in mind and targets both application and computer scientists. <br>
    &nbsp;<br>
    Open|SpeedShop's base functionality includes exclusive and inclusive
    user time, MPI call tracing, and CPU hardware performance counter
    experiments.&nbsp; In addition, Open|SpeedShop is designed to be
    modular and extensible.&nbsp; It supports several levels of plugins
    which allow users to add their own performance experiments. <br>
    <br>
    The infrastructure and base components of Open|SpeedShop are being
    released open source under GPL and LGPL.
    <h3><a class="mozTocH4" name="mozTocId507487"></a>Features:</h3>
    <ul>
      <li>Three modes of operation: batch, interactive command line
        interface, and graphical user interface.</li>
      <li>Multiple platform single system image (SSI), traditional
        cluster, and SGI super cluster support.</li>
      <li>Support for large numbers of processes, threads, and ranks.</li>
      <li>Ability for users to create their own experiments via a well
        defined plugin facility.<br>
      </li>
      <li>Ability to attach to running processes, threads, and ranks to
        gather performance data.</li>
      <li>Ability to view performance data for all of application's
        lifetime or smaller time slices.</li>
      <li>Ability to view performance data on demand (while the
        experiment is running).</li>
      <li>Ability to save and restore performance experiment data and
        symbol information to do post experiment performance analysis.</li>
      <li>Ability to compare performance results for processes, threads,
        ranks, or to compare current experiment results with previous
        experiment results.</li>
      <li>GUI Wizard facility and context sensitive help to aid in tools
        usability.&nbsp; <br>
      </li>
      <li>CLI help facility which lists the CLI commands, syntax, and
        typical usage. <br>
      </li>
    </ul>
    <h3><a class="mozTocH3" name="mozTocId88877"></a>Open|SpeedShop
      Component Diagram</h3>
    <h4><a class="mozTocH4" name="mozTocId74182"></a>Host/Client
      Component Diagram<br>
    </h4>
    This diagram illustrates the interactions of the Open|SpeedShop
    client components.&nbsp;&nbsp; An item note in this diagram is that
    the Command Line Interface is at the center of the user interface
    options for Open|SpeedShop.&nbsp;&nbsp; All user interface requests
    come through the Command Line Interface.&nbsp;&nbsp; The Command
    Line Interface interprets the CLI commands and interacts with the
    Open|SpeedShop Framework component to execute the commands.<br>
    <br>
    The Framework is at the heart of the Open|SpeedShop
    tool.&nbsp;&nbsp; It interacts with the User Interface, Maintains
    the Performance Experiment Database, forces victim application
    performance gathering instrumentation, obtains performance data back
    from the victim application, and stores the performance data into
    the Performance Experiment Database file. <br>
    <br>
    <br>
    <img alt="Open|SpeedShop Client Overview" title="Open|SpeedShop
      Client Overview" src="ToolClientOverView.png" style="width: 741px;
      height: 450px;"><br>
    <br>
    <h4><a class="mozTocH4" name="mozTocId377936"></a>Runtime/Server
      Component Diagram</h4>
    This diagram illustrates the interactions of the Open|SpeedShop
    server components.&nbsp;&nbsp; <br>
    <br>
    The Dyninst component is at the heart of the server portion
    Open|SpeedShop tool.&nbsp;&nbsp; It interacts with the DPCL
    component to control the victim application being analyzed for
    performance.&nbsp; Dyninst inserts into the victim application
    performance gathering instrumentation, obtains performance data back
    from the victim application, and sends the performance data back to
    the client side of the Open|SpeedShop tool.<br>
    <br>
    <br>
    <img alt="Open|SpeedShop Server/Runtime Diagram"
      src="ToolServerOverView6.png" style="width: 900px; height: 524px;"><br>
    <br>
    <br>
    <h3><a class="mozTocH4" name="mozTocId251693"></a>Information
      Resources:</h3>
    Additional information about Open|SpeedShop usage and design can be
    found in a number of Open|SpeedShop documents.&nbsp; The currently
    available documents are:<br>
    <ul>
      <li><a href="../design_doc/index.html">Open|SpeedShop Design
          Document&nbsp;</a> - Outlines the Open|SpeedShop design by
        major component.<a href="../design_doc/index.html"><br>
        </a></li>
      <li><a href="../users_guide/index.html">Open|SpeedShop Users Guide</a>
        - Describes build, installation, and usage of the Open|SpeedShop
        tools</li>
      <li><a href="../cli_doc/index.html">Open|SpeedShop Command Line
          Interface</a> - Detailed description of the CLI commands and
        usage<br>
      </li>
      <li><a href="../test_plan/SGI_TestPlan.html">Open|SpeedShop Test
          Pla</a><a href="../test_plan/SGI_TestPlan.html">n</a> -
        Testing plan description<br>
      </li>
      <li><a href="../usability_plan/UsabilityPlanforOpenSpeedShop.html">Open|SpeedShop
Usability
Study

          Plan and Detailed Results</a> - List of Usability Studies and
        Results of Conducted Studies<br>
      </li>
    </ul>
    <h2><a class="mozTocH2" name="mozTocId351566"></a>General Plugin
      Definition</h2>
    A plugin is a mechanism that allows new functionality to be added to
    a software program without having to change the infrastructure of
    the existing software program.&nbsp;&nbsp; The new plugin creator
    can add additional features by following a set of rules and using a
    set of well defined function calls (API) to create a
    plugin.&nbsp;&nbsp; In general most tool's plugin API and rules are
    different from another tools plugin API and plugin rules.&nbsp;
    However, the basic concepts are the same.&nbsp; The plugin needs to
    be recognized as a software entity that is associated with the base
    software tool.&nbsp; Plugins have to be dynamically shared objects
    in order for the base software tool to dynamically link in the
    plugin.&nbsp; There may also be entry points that the base software
    program looks for in the dynamic shared object to verify that the
    shared object is associated with it.<br>
    <br>
    When the plugin is verified to be compatible with the base software
    program the base software program updates it's internal data
    structures and an applicable user interface items that would make
    the new functionality available to the user.<br>
    <br>
    Open|SpeedShop uses this methodology.&nbsp;&nbsp; This document
    describes how to create an Open|SpeedShop specific plugin.<br>
    <br>
    <h2><a class="mozTocH2" name="mozTocId11413"></a>Open|SpeedShop
      Plugin Overview<br>
    </h2>
    The Open|SpeedShop performance tool is oriented toward gathering
    performance data from user applications and relating that
    performance data back to the application source file, function name
    and line number(s).&nbsp;&nbsp;&nbsp; The data gathering, graphical
    user interface displays, and the command line interface views are
    defined via the Open|SpeedShop plugin mechanism.&nbsp;&nbsp; What
    this means is that the code and data required to accomplish the
    above mentioned data gathering, GUI control and display panels, and
    the CLI displays is compiled into a dynamically loaded object called
    a plugin.&nbsp;&nbsp; The Open|SpeedShop tools search a specified
    directory path or paths to find the plugins and dynamically load
    them. &nbsp; Open|SpeedShop uses the information inside the plugin
    to adjust the tools menus, internal data structures, etc. to
    integrate the functionality contained in the plugins into the tool.<br>
    <br>
    A key point to be aware of while studying the plugin structure of
    Open|SpeedShop, is that although Open|SpeedShop currently uses
    Dyninst as it's dynamic instrumentation package and uses DPCL as the
    cluster support package, their APIs are not exposed to the plugin
    writer.&nbsp;&nbsp; This is a design decision that allows those
    packages to be replaced or modified without impact to the plugin
    interface.&nbsp; Open|SpeedShop wraps the functionality to hide the
    instrumentation details from the plugin writer.<br>
    <br>
    There are currently three separate types of Plugins that
    Open|SpeedShop recognizes and dynamically integrates into the
    Open|SpeedShop tool set.&nbsp; The three types of plugins are:<br>
    <ul>
      <li>Performance data collector plugins <br>
      </li>
      <ul>
        <li>Collector Runtime - run time plugin - loaded into victim
          application</li>
        <li>Collector Plugin - client side plugin - loaded into
          Open|SpeedShop client tool<br>
        </li>
      </ul>
      <li>Graphical User Interface plugins</li>
      <li>Command Line Interface plugins</li>
    </ul>
    This document will outline each of the plugin types and give
    instruction and examples of how to create and integrate plugins into
    the Open|SpeedShop tools.<br>
    <h3><a class="mozTocH3" name="mozTocId1962"></a><a
        name="Plugin_Creation_QuickStart"></a>Plugin Creation Creation
      Notes<br>
    </h3>
    These <a href="PluginCreationNotes.html">plugin collector creation
      notes</a> are from actual developers that have used this guide to
    build new Open|SpeedShop plugins.&nbsp; They are included here as
    additional information.&nbsp;&nbsp; In addition, notes on how to
    create an additional graphical user interface plugin can be found <a
      href="GUIPluginCreationNotes.html">here</a>.<br>
    <h3><a class="mozTocH3" name="mozTocId405706"></a>Plugin Creation
      Outline</h3>
    Before getting into all the details, it may be helpful to outline
    the steps involved in writing Open|SpeedShop plugins from a high
    level.&nbsp; The following outline indicates the basic steps needed
    in creating Open|SpeedShop plugins.&nbsp;&nbsp; If some steps aren't
    clear at this point, don't despair, they will be explained
    later.&nbsp;&nbsp; The purpose of this section is to give a broad
    overview and context to the specific steps that are described in the
    rest of the document.<br>
    <br>
    <h4><a class="mozTocH4" name="mozTocId513127"></a><a
        name="General_OpenSpeedShop_Plugin_Outline"></a>General
      Open|SpeedShop Plugin Outline</h4>
    See each of the following sections for the plugin specific
    outline.&nbsp;&nbsp; As stated above, there are currently three
    types of plugins that can be created in the Open|SpeedShop
    tools.&nbsp; The following list links to each of the plugin
    outlines:<br>
    <ul>
      <li><a href="#Performance_Data_Collector_Plugin_Outline">Performance
Data
Collector

          Plugin Outline</a></li>
      <li><a href="#GUI_Plugin_Outline">GUI Plugin Outline</a></li>
      <li><a href="#Interactive_Command_Line_Interface_CLI__">Interactive
Command

          Line Interface Plugin Outline</a><br>
      </li>
    </ul>
    <h4><a class="mozTocH4" name="mozTocId225587"></a><a
        name="General_Plugin_Structure"></a>General Plugin Structure</h4>
    <h5><a class="mozTocH5" name="mozTocId64311"></a>Performance Data
      Collector Plugin Structure</h5>
    As noted above, the experiment collector plugin is actually
    physically two dynamic shared objects.&nbsp; If one was to view the
    directory where the Open|SpeedShop plugins are installed
    (&lt;install_dir_prefix&gt;/lib/openspeedshop) you would see that
    there are two dso's for each experiment collector.&nbsp;&nbsp; For
    example, here is what is shown for the PC Sampling experiment
    collector:<br>
    <div style="text-align: left;"><small><span style="font-style:
          italic;">pcsamp.la*&nbsp; pcsamp-rt.la*&nbsp;
          pcsamp-rt.so*&nbsp; pcsamp.so*</span></small><br>
    </div>
    <br>
    The runtime portion of the experiment collector plugin is appended
    with "-rt" while the client portion is not.<br>
    <h5><a class="mozTocH5" name="mozTocId300839"></a>GUI Plugin
      Structure<br>
    </h5>
    GUI plugins have on physical shared object for each
    panel.&nbsp;&nbsp; For the pcsamp experiment,&nbsp; a listing of the
    plugin directory would show these files:<br>
    <small><small><span style="font-style: italic;"><big>pcSamplePanel.la*&nbsp;

            pcSamplePanel.so*</big>&nbsp; </span></small><br>
    </small><br>
    Additionally, one would see another dynamically shared object
    relating to the PC Sampling experiment.&nbsp; However, support for
    creating wizard plugins is not available at this time.<br>
    <small><span style="font-style: italic;">pcSampleWizardPanel.la*&nbsp;

        pcSampleWizardPanel.so*</span><span style="font-style: italic;
        font-weight: bold;"><big><span style="font-weight: bold;"><span
              style="font-style: italic;"></span></span></big></span></small><br>
    <br>
    <h5><a class="mozTocH5" name="mozTocId337518"></a>Interactive CLI
      Plugin Structure</h5>
    Support for the interactive command line interface plugins is tbd.<br>
    <h4><a class="mozTocH4" name="mozTocId743777"></a>How do plugins get
      recognized?</h4>
    The keys to Open|SpeedShop recognizing that a file is an
    Open|SpeedShop plugin are listed here.&nbsp; The keys are described
    in more details in the sections describing the implementation of the
    respective plugins.&nbsp; The high level list of factors that
    indicate a file is an Open|SpeedShop plugin are:<br>
    <ul>
      <li>The file is in the default plugin directory path or a
        directory specified by the environment variable:
        OPENSS_PLUGIN_PATH.</li>
      <li>The file is a dynamically linked object (dso) - can dlopen the
        file.<br>
      </li>
      <li>A specific named entry point exists in the dso and is
        callable.</li>
    </ul>
    There are additional details that are described in the plugin
    specific sections below.<br>
    <h4><a class="mozTocH4" name="mozTocId679293"></a>Where are the
      plugins located?</h4>
    Open|SpeedShop recognizes the OPENSS_PLUGIN_PATH environment
    variable and will search the directory path supplied by this
    environment variable to find user created plugins.&nbsp;&nbsp; This
    environment variable provides an additional plugin path and does not
    override the Open|SpeedShop default plugin location
    path.&nbsp;&nbsp;&nbsp; The plugins can be in any accessible
    directory as long as the OPENSS_PLUGIN_PATH environment variable
    specifies that path path.<br>
    <br>
    The Open|SpeedShop default plugin search path is based on the
    "--prefix" specified for the Open|SpeedShop build and
    installation.&nbsp;&nbsp; Open|SpeedShop follows the GNU convention
    which specifies the package name appended the
    &lt;install_dir&gt;/lib/&lt;package_name&gt; for the plugin
    path.&nbsp;&nbsp;&nbsp; Based on the GNU convention,&nbsp; the path
    to the default plugin directory for Open|SpeedShop is
    &lt;install_dir&gt;/lib/openspeedshop.<br>
    <br>
    <h2><a class="mozTocH2" name="mozTocId732797"></a>Performance Data
      Collector Plugin Information</h2>
    Writing a performance data collector consists of several
    steps.&nbsp;&nbsp; The first step is to think about the performance
    data that is to be collected.&nbsp; This first step can be
    characterized as identifying and analyzing the performance data
    desired.&nbsp;&nbsp; See the section below that is dedicated to the
    outlining the details associated with this action.&nbsp; Once the
    performance data criteria are resolved the next step in the
    collector plugin creation is the actual implementation
    action.&nbsp;&nbsp; See the sections below that are associated with
    implementation and also the section detailing a performance data
    collector plugin example.<br>
    <h3><a class="mozTocH3" name="mozTocId892980"></a>Performance Data
      Collector Quick Overview<br>
    </h3>
    <h4><a class="mozTocH4" name="mozTocId952547"></a><a
        name="Performance_Data_Collector_Plugin_Outline"></a>Performance
      Data Collector Plugin Outline</h4>
    For building a performance data collector plugin these are the high
    level steps in outline form:<br>
    <ul>
      <li>Identify and evaluate the performance data you want to gather.</li>
      <ul>
        <li>Can it be mapped back to the source line numbers or function
          definitions?</li>
        <li>What's the goal?&nbsp; Identify the metrics - the
          performance data desired to be output by the Open|SpeedShop
          tool.</li>
      </ul>
      <li>Determine what will be in the performance data structure (data
        blob) in the victim application.</li>
      <ul>
        <li>Analyze and define the data blob structure</li>
        <ul>
          <li>Too much information (large data blobs) might impact the
            victim applications behavior (memory growth).</li>
          <li>Sending lots of small data blobs could cause network
            performance issues.</li>
        </ul>
      </ul>
      <li>Create a bare bones directory using the Example Plugin
        directory as a model or copy the Example Plugin directory and
        modify the files accordingly</li>
      <ul>
        <li>Note:&nbsp; The Example Plugin is the simplest plugin code
          found in the Open|SpeedShop source directory.&nbsp; However,
          if there is an already implemented plugin that is closer in
          functionality to what the plugin writer is implementing, then
          starting with that plugin makes more sense than starting with
          the Example Plugin.<br>
        </li>
      </ul>
      <li>Proceed on the actual implementation of the collector plugin</li>
      <ul>
        <li>Create base files using Example Plugin files as model/guide</li>
        <li>Implement the plugin recognition portion of the plugin</li>
        <li>Implement the performance data definitions (data blob
          structure) for the data gathered by the collector runtime.</li>
        <li>Implement the runtime code that gathers the performance data
          defined by the data blob (runtime.c file)</li>
        <li>Implement the six virtual functions that are required for
          the client portion of the collector.</li>
        <li>Compile and build plugins using the Makefile.am file as a
          guide or modify the Makefile.am file</li>
        <ul>
          <li>To build in place modify the
            &lt;top_srcdir&gt;/configure.ac and
            &lt;top_srcdir&gt;/Makefile.am files to include the new
            collector directory.</li>
          <li>Test and refine the new collector</li>
          <li>Point OPENSS_PLUGIN_PATH to the directory with the new
            collector plugins if not installed in the default location.</li>
        </ul>
      </ul>
    </ul>
    <a href="#General_OpenSpeedShop_Plugin_Outline">Return to General
      Plugin Section</a><br>
    <h4><a class="mozTocH4" name="mozTocId636342"></a><span
        class="mozTocH4"></span>Performance Data Collector Plugin
      Structure</h4>
    As noted above, the experiment collector plugin is actually
    physically two dynamic shared objects.&nbsp; If one was to view the
    directory where the Open|SpeedShop plugins are installed
    (&lt;install_dir_prefix&gt;/lib/openspeedshop) you would see that
    there are two dso's for each experiment collector.&nbsp;&nbsp; For
    example, here is what is shown for the PC Sampling experiment
    collector:<br>
    <br>
    <div style="text-align: left;"><span style="font-style: italic;">pcsamp.la*&nbsp;

        pcsamp-rt.la*&nbsp; pcsamp-rt.so*&nbsp; pcsamp.so*</span><br>
    </div>
    <br>
    The runtime portion of the experiment collector plugin is appended
    with "-rt" while the client portion is not.<br>
    <br>
    <br>
    <h3><a class="mozTocH3" name="mozTocId661443"></a><a
        name="Idenitifying_and_Analysing_The"></a>Identifying and
      Analyzing The Performance Data Desired</h3>
    The first step is the thought process which identifies the
    performance data desired to be collected.&nbsp; In other words,
    "What performance information do we want to try and
    collect?".&nbsp;&nbsp; Open|SpeedShop allows the user to collect the
    performance data and then map the gathered data back to the program
    source function name and/or source line numbers.&nbsp;&nbsp; One
    question to be asked before starting to write a collector plugin for
    Open|SpeedShop is can the performance data desired&nbsp; be
    associated with the program's source line and function
    addresses.&nbsp; Does the performance data map back to the
    source?&nbsp;&nbsp; If so, then it is a candidate to be gathered by
    an Open|SpeedShop plugin.&nbsp;&nbsp;&nbsp; <br>
    <br>
    For example, the PC Sampling experiment takes periodic samples of
    the program address counter.&nbsp;&nbsp; A periodic timer is set and
    when it triggers, the address of where the program is executing at
    that point is saved.&nbsp;&nbsp; The address can be mapped back to
    the source program because we have saved the address in the program,
    as the performance data gathered.&nbsp;&nbsp; We can, by using
    debugging information, map the saved addresses back to the program's
    source.&nbsp;&nbsp; Actually, a set of addresses and the count of
    the times each address is "hit" are saved.<br>
    <br>
    Another part of this step is to identify and define the metric and
    parameters.&nbsp; The metric is a function of the time intervals and
    the instruction address space.&nbsp;&nbsp; It is also the basic item
    of performance data that is to be gathered and displayed by the
    collector plugin.&nbsp; The parameter(s) can be thought of as the
    dial, selector, or knob that controls how the data is
    collected.&nbsp;&nbsp; For example, the PC Sampling experiment
    gathers the application's address at time intervals across the
    applications running time.&nbsp; The time interval at which each
    address sample is taken is the dial, selector, or knob controlling
    how (actually when)&nbsp; the data is collected.&nbsp;&nbsp; The
    metric, in this case, is time spent in the application's functions
    and source line numbers based on translating the addresses that were
    gathered, back to the source function names and line numbers.<br>
    <br>
    Given that the "metric" is the performance data item desired to be
    displayed and that the "parameter(s)" is the dial, selector, or knob
    to control the collection of the "metric", lets examine these items
    in more detail.&nbsp;&nbsp;&nbsp; <br>
    <br>
    Examples of metrics already being collected in Open|SpeedShop are:<br>
    <ul>
      <li>Exclusive time - Time spent in this function only</li>
      <li>Inclusive time - Time spent in this function and all functions
        it calls.</li>
      <li>Numbers of event occurrences, such as hardware counter events<br>
      </li>
    </ul>
    Examples of parameters already supported by Open|SpeedShop are:<br>
    <ul>
      <li>Sampling Rate in milliseconds</li>
      <li>Trigger Count Number of Events (the number of event
        occurrences before a sample is taken)<br>
      </li>
    </ul>
    <br>
    <span style="font-weight: bold; font-style: italic; text-decoration:
      underline;">Key point: <br>
      If the parameter is a type that is already supported by
      Open|SpeedShop, additional GUI and/or CLI plugins may not have to
      be written to support the new collector plugin.&nbsp;&nbsp; Since,
      the existing types are recognized, a generic view can display the
      performance data.<br>
    </span><span style="font-weight: bold; font-style: italic;
      text-decoration: underline;"><br>
    </span><br>
    <h3><a class="mozTocH3" name="mozTocId904911"></a><a
        name="Implementating_The_Collector_Plugin"></a>Implementing The
      Collector Plugin</h3>
    <h4><a class="mozTocH4" name="mozTocId773274"></a>Overview</h4>
    This section provides a brief implementation related overview of
    what is going on inside Open|SpeedShop with respect to the
    interactions of the collector plugin with the other components of
    the tool and with the application being analyzed.&nbsp;&nbsp; A
    collector plugin will facilitate Open|SpeedShop to gather
    performance measurements that will be gathered and stored
    temporarily in the victim application.&nbsp; This performance data
    is sent from the victim application to the Open|SpeedShop client
    when the performance data buffer fills up in the victim
    application.&nbsp;&nbsp; When the Open|SpeedShop client receives the
    performance data it is stored in the experiment database file.<br>
    <br>
    <img alt="Tool Overview" src="ToolOverView.png" style="width: 851px;
      height: 394px;"><br>
    <br>
    <h4><a class="mozTocH4" name="mozTocId223455"></a>Plugin Recognition</h4>
    The Open|SpeedShop framework component, using libltdl, will search
    the plugin directory paths for files that can be dynamically opened,
    (dso) via dlopen.&nbsp; It then opens the dso files and look for a
    special entry point,
    "&lt;plugin_name&gt;_LTX_CollectorFactory".&nbsp;&nbsp; If this
    entry point is found, and it is the only visible entry point in the
    dynamically shared object file then the file is recognized as a
    plugin.&nbsp;&nbsp; At this point further plugin verification and
    creation processing occurs.&nbsp;&nbsp; The&nbsp; CollectorFactory
    function is&nbsp; called to create&nbsp; a new instantiation of the
    "CollectorImpl" class which, in reality, creates the collector
    plugin.&nbsp;&nbsp; The code that is responsible for the
    instantiation can be found in&nbsp; the Open|SpeedShop source file
    "libopenss-framework/CollectorPluginTable.cxx" in CollectorImpl*
    CollectorPluginTable::instantiate function.&nbsp; No changes are
    required by the plugin writer in this function.&nbsp; This
    information is included here for completeness.&nbsp; The unique
    identification code of the collector plugin is also checked in this
    routine to see if the plugin has already been encountered.&nbsp; If
    it has not been encountered yet, it is added to the list of
    collector plugins.&nbsp;&nbsp; The collector is actually added to
    the collector list in the function "Collector::instantiateImpl"
    which is found in the Open|SpeedShop source file
    "libopenss-framework/Collector.cxx".<br>
    <br>
    So, to assure that the plugin you are creating is found, make sure
    you define the special entry point
    "&lt;your_plugin_name&gt;_LTX_CollectoryFactory".&nbsp;&nbsp;&nbsp;
    The Example collector plugin shows this in the file
    "examples/libopenss-framework/collector/ExampleCollector.cxx"&nbsp;&nbsp;&nbsp;
Here
is

    the definition of "example_LTX_CollectorFactory()" from the example
    collector. <br>
    <br>
    <small><span style="font-style: italic;">/**</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* Collector's factory
        method.</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;*</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* Factory method for
        instantiating a collector implementation. This is the</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* only function that is
        externally visible from outside the collector plugin.</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;*</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;*
        @return&nbsp;&nbsp;&nbsp; New instance of this collector's
        implementation.</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;*/</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">extern "C" CollectorImpl*
        example_LTX_CollectorFactory()</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">{</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; return new
        ExampleCollector();</span><br style="font-style: italic;">
      <span style="font-style: italic;">}</span></small><br>
    <h4><a class="mozTocH4" name="mozTocId207808"></a><a
        name="Data_blobs"></a><a name="Data_blobs_"></a>Data blobs</h4>
    The collector writer defines the format of the performance data
    being gathered and stored in the victim application.&nbsp;&nbsp;
    Open|SpeedShop uses the term, blob (binary large object), to refer
    to the performance data objects being gathered and stored in the
    victim application.&nbsp; <br>
    <br>
    This is a very important phase of the collector
    creation!&nbsp;&nbsp; Much time needs to be spent in the design and
    layout of the data blob data definitions to optimize the data
    layout.&nbsp; Having an optimal data layout in size and content will
    help to create an experiment that executes efficiently.&nbsp;&nbsp;
    Size considerations and making sure only the necessary performance
    data items are stored are the two main considerations.<br>
    <br>
    &nbsp;The design issues to consider when defining the structure and
    size of the blob data are:<br>
    <ul>
      <li>Try not to use too much memory because the blob is contained
        in the victim application.</li>
      <li>The blob should not be too small because having to send many
        small blobs across the network could slow the network down.</li>
      <li>16k bytes have been found to be a reasonable size.&nbsp;&nbsp;
        PC Sampling currently uses 8k bytes as the blob size.</li>
      <li>16k bytes is the high limit on the buffer size able to be sent
        in a message from the Open|SpeedShop runtime to the client tool.<br>
      </li>
    </ul>
    Data blobs are specified in the XDR (External Data Representation)
    language.&nbsp;&nbsp; XDR deals with endianess issues, data packing,
    and other related issues.&nbsp;&nbsp; The XDR language looks like a
    C structure definition and is specified in a file call
    blob.x.&nbsp;&nbsp; This is what the collector plugin expects.&nbsp;
    The blob.x file is fed into rpcgen which generates a ".c" file and
    an ".h" file.&nbsp; These files create a compilable C structure and
    functions to convert the data to a C structure and back.<br>
    <h5><a class="mozTocH5" name="mozTocId281427"></a>blobs.x:</h5>
    For the example collector the blobs.x XDR language defines the
    experiments parameter(s), performance data, and the structure to
    pass parameters to the runtime/victim start_sampling routine.<br>
    <br>
    <small><span style="font-style: italic;">/** Structure of the blob
        containing our parameters. */</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">struct example_parameters {</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; unsigned
        sampling_rate;&nbsp; /**&lt; Sampling rate in samples/second. */</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">};</span><br style="font-style:
        italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">/** Structure of the blob
        containing our performance data. */</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">struct example_data {</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; uint64_t
        interval;&nbsp;&nbsp;&nbsp; /**&lt; Sampling interval in
        nanoseconds. */</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; uint64_t
        pc&lt;&gt;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /**&lt;
        Program counter (PC) addresses. */</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">};</span><br style="font-style:
        italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">/** Structure of the blob
        containing example_start_sampling()'s arguments. */</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">struct
        example_start_sampling_args {</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; unsigned
        sampling_rate;&nbsp; /**&lt; Sampling rate in samples/second. */</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; int
        experiment;&nbsp; /**&lt; Identifier of experiment to contain
        the data. */</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; int
        collector;&nbsp;&nbsp; /**&lt; Identifier of collector gathering
        data. */</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; int
        thread;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /**&lt; Identifier of
        gathered data's thread. */</span><br style="font-style: italic;">
      <span style="font-style: italic;">};<br>
      </span></small><small><span style="font-style: italic;"></span></small>
    <p><small><a href="#Data_blobs_">Return to top of Data blobs section</a></small><br>
    </p>
    <h5><a class="mozTocH5" name="mozTocId57477"></a>blobs.h:</h5>
    The blob data structures are used both by the Collector Runtime
    plugin (server/victim side) and also by the Collector plugin (client
    side).&nbsp; <br>
    Excerpts from the blobs.h file are shown here.&nbsp; Note the
    similarity between the C structures here, in blobs.h, with the XDR
    definitions in blobs.x.<br>
    <br>
    <small><span style="font-style: italic;">struct example_parameters {</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        u_int sampling_rate;</span><br style="font-style: italic;">
      <span style="font-style: italic;">};</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">typedef struct
        example_parameters example_parameters;</span><br
        style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">struct example_data {</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        uint64_t interval;</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        struct {</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        u_int pc_len;</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        uint64_t *pc_val;</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        } pc;</span><br style="font-style: italic;">
      <span style="font-style: italic;">};</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">typedef struct example_data
        example_data;</span><br style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">struct
        example_start_sampling_args {</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        u_int sampling_rate;</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        int experiment;</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        int collector;</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        int thread;</span><br style="font-style: italic;">
      <span style="font-style: italic;">};</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">typedef struct
        example_start_sampling_args example_start_sampling_args;</span><br
        style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">/* the xdr functions */</span><br
        style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">#if defined(__STDC__) ||
        defined(__cplusplus)</span><br style="font-style: italic;">
      <span style="font-style: italic;">extern&nbsp; bool_t
        xdr_example_parameters (XDR *, example_parameters*);</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">extern&nbsp; bool_t
        xdr_example_data (XDR *, example_data*);</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">extern&nbsp; bool_t
        xdr_example_start_sampling_args (XDR *,
        example_start_sampling_args*);</span><br style="font-style:
        italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">#else /* K&amp;R C */</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">extern bool_t
        xdr_example_parameters ();</span><br style="font-style: italic;">
      <span style="font-style: italic;">extern bool_t xdr_example_data
        ();</span><br style="font-style: italic;">
      <span style="font-style: italic;">extern bool_t
        xdr_example_start_sampling_args ();</span><br style="font-style:
        italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">#endif /* K&amp;R C */<br>
        <br>
      </span></small><small><a href="index.html#Data_blobs_">Return to
        top of Data blobs section</a></small><br>
    <h5><a class="mozTocH5" name="mozTocId839482"></a>blobs.c:</h5>
    In blobs.c, we see routines that are generated by rpcgen.&nbsp;
    These routines contain code using XDR functionality&nbsp; to return
    the experiments (example in this case) parameter and data.&nbsp; The
    blob "C" files are compiled into each of the plugins (runtime and
    client) that represent the collector.&nbsp; Excerpts from the
    blobs.c file are shown here.<br>
    <br>
    <br>
    <small><span style="font-style: italic;">#include "blobs.h"</span><br
        style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">bool_t</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">xdr_example_parameters (XDR
        *xdrs, example_parameters *objp)</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">{</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
register
int32_t

        *buf;</span><br style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if
(!xdr_u_int

        (xdrs, &amp;objp-&gt;sampling_rate))</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        return FALSE;</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        return TRUE;</span><br style="font-style: italic;">
      <span style="font-style: italic;">}</span><br style="font-style:
        italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">bool_t</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">xdr_example_data (XDR *xdrs,
        example_data *objp)</span><br style="font-style: italic;">
      <span style="font-style: italic;">{</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
register
int32_t

        *buf;</span><br style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if
(!xdr_uint64_t

        (xdrs, &amp;objp-&gt;interval))</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        return FALSE;</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if
(!xdr_array

        (xdrs, (char **)&amp;objp-&gt;pc.pc_val, (u_int *)
        &amp;objp-&gt;pc.pc_len, ~0,</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
sizeof
(uint64_t),

        (xdrproc_t) xdr_uint64_t))</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        return FALSE;</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        return TRUE;</span><br style="font-style: italic;">
      <span style="font-style: italic;">}<br>
      </span></small><small><a href="index.html#Data_blobs_">Return to
        top of Data blobs section</a></small><small><span
        style="font-style: italic;"></span></small><br>
    <h4><a class="mozTocH4" name="mozTocId667687"></a><a
        name="Collector_Runtime_-_ServerVictim_"></a><a
        name="Collector_Runtime_-_ServerVictim"></a>Collector Runtime -
      Server/Victim portion of Experiment Collector<br>
    </h4>
    The collector runtime gathers data dependent on the type of
    performance data the collector writer has decided to
    gather.&nbsp;&nbsp;&nbsp; The collector runtime's purpose is to
    gather the data, package it, and send it from the victim application
    to the Open|SpeedShop experiment collector plugin
    client.&nbsp;&nbsp; Functionality that is generally needed by
    collector runtime plugins includes the following.&nbsp;&nbsp;&nbsp;
    Note that the code examples in this section reference a thread local
    storage structure which holds thread specific information (see <a
      href="#Thread_specific_data">Thread Specific Data</a> for the
    definition).<br>
    <ul>
      <li>Setting up a timer to trigger the gathering of performance
        data (see <a href="#Timer_event_handler">Timer event handler</a>
        for example code)<small style="font-style: italic;"></small><small
          style="font-style: italic;"></small></li>
      <li>Start Sampling - enable Open|SpeedShop to gather performance
        data (see <a href="#Start_Sampling">Start Sampling</a> for
        example code)</li>
      <li>Stop Sampling - disable Open|SpeedShop's gathering of
        performance data (see <a href="#Stop_Sampling">Stop Sampling</a>
        for example code)<br>
      </li>
      <li>Using the PAPI overflow mechanism</li>
      <li>Obtaining a callstack entry</li>
      <li>Getting a program counter (PC) address</li>
      <li>Putting the collected data into a data blob</li>
      <li>Compressing the data to increase the bandwidth when sending to
        the tool host (collector plugin client)<br>
      </li>
      <li>Sending the data to the tool host when the buffer (blob) fills
        up and on program termination</li>
    </ul>
    There is also a set of commonly used shared functions that are
    bundled into the Open|SpeedShop libopenss-runtime dynamic
    object.&nbsp;&nbsp; These are functions that are used by more than
    one collector.&nbsp;&nbsp; For example, some of the libunwind
    functionality is contain in the libopenss-runtime dynamic
    object.&nbsp; The implementation of this portion of the collector is
    contained in the file "runtime.c"&nbsp;&nbsp; The runtime versions
    of start and stop sampling are contained in this file.<br>
    <br>
    <h5><a class="mozTocH5" name="mozTocId612900"></a><a
        name="Thread_specific_data"></a>Thread Specific Data</h5>
    <small><span style="font-style: italic;">/** Thread-local storage.
        */</span><br style="font-style: italic;">
      <span style="font-style: italic;">static __thread struct {</span><br
        style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        OpenSS_DataHeader header;&nbsp; /**&lt; Header for following
        data blob. */</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; example_data
        data;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /**&lt;
        Actual data blob. */</span><br style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; /** Sample
        buffer. */</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; struct {</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
uint64_t
pc[BufferSize];&nbsp;

        /**&lt; Program counter (PC) addresses. */</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; } buffer;</span><br
        style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">} tls;</span></small><br>
    <br>
    <br>
    <h5><a class="mozTocH5" name="mozTocId973451"></a><a
        name="Timer_event_handler"></a>Timer event handler</h5>
    <small style="font-style: italic;">/**<br>
      &nbsp;* Timer event handler.<br>
      &nbsp;*<br>
      &nbsp;* Called by the timer handler each time a sample is to be
      taken. Extracts the<br>
      &nbsp;* program counter (PC) address from the signal context and
      places it into the<br>
      &nbsp;* sample buffer. When the sample buffer is full, it is sent
      to the framework<br>
      &nbsp;* for storage in the experiment's database.<br>
      &nbsp;*<br>
      &nbsp;* @param context&nbsp;&nbsp;&nbsp; Thread context at timer
      interrupt.<br>
      &nbsp;*/<br>
      static void exampleTimerHandler(const ucontext_t* context)<br>
      {<br>
      &nbsp;&nbsp;&nbsp; uint64_t pc;<br>
      <br>
      &nbsp;&nbsp;&nbsp; /* Obtain the program counter (PC) address from
      the thread context */<br>
      &nbsp;&nbsp;&nbsp; pc = OpenSS_GetPCFromContext(context);<br>
      <br>
      &nbsp;&nbsp;&nbsp; /* Add a new entry for this PC address to the
      sample buffer */<br>
      &nbsp;&nbsp;&nbsp; tls.buffer.pc[tls.data.pc.pc_len++] = pc;<br>
      <br>
      &nbsp;&nbsp;&nbsp; /* Update the address interval in the data
      blob's header */<br>
      &nbsp;&nbsp;&nbsp; if(pc &lt; tls.header.addr_begin)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tls.header.addr_begin =
      pc;<br>
      &nbsp;&nbsp;&nbsp; if(pc &gt; tls.header.addr_end)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tls.header.addr_end =
      pc;<br>
      <br>
      &nbsp;&nbsp;&nbsp; /* Is the sample buffer full? */<br>
      &nbsp;&nbsp;&nbsp; if(tls.data.pc.pc_len == BufferSize) {<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Send these samples
      */<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tls.header.time_end =
      OpenSS_GetTime();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      OpenSS_Send(&amp;(tls.header), (xdrproc_t)xdr_example_data,
      &amp;(tls.data));<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Re-initialize the
      data blob's header */<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tls.header.time_begin =
      tls.header.time_end;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tls.header.time_end =
      0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tls.header.addr_begin =
      ~0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tls.header.addr_end =
      0;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Re-initialize the
      actual data blob */<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tls.data.pc.pc_len = 0;<br>
      <br>
      &nbsp;&nbsp;&nbsp; }<br>
      }</small><br>
    <a href="#Collector_Runtime_-_ServerVictim_"><small>Back To
        Collector Runtime - Server/Victim portion of Experiment
        Collector</small></a><br>
    <br>
    <h5><a class="mozTocH5" name="mozTocId10166"></a><a
        name="Start_Sampling"></a>Start Sampling</h5>
    <small><span style="font-style: italic;">/**</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* Start sampling.</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;*</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* Starts program counter
        (PC) sampling for the thread executing this function.</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* Initializes the
        appropriate thread-local data structures and then enables the</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* sampling timer.</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;*</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* @param
        arguments&nbsp;&nbsp;&nbsp; Encoded function arguments.</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;*/</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">void
        example_start_sampling(const char* arguments)</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">{</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        example_start_sampling_args args;</span><br style="font-style:
        italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; /* Decode the
        passed function arguments. */</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        memset(&amp;args, 0, sizeof(args));</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        OpenSS_DecodeParameters(arguments,</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        (xdrproc_t)xdr_example_start_sampling_args,</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        &amp;args);</span><br style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; /* Initialize
        the data blob's header */</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        tls.header.experiment = args.experiment;</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        tls.header.collector = args.collector;</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        tls.header.thread = args.thread;</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        tls.header.time_begin = 0;</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        tls.header.time_end = 0;</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        tls.header.addr_begin = ~0;</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        tls.header.addr_end = 0;</span><br style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; /* Initialize
        the actual data blob */</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        tls.data.interval = (uint64_t)(1000000000) /
        (uint64_t)(args.sampling_rate);</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        tls.data.pc.pc_len = 0;</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        tls.data.pc.pc_val = tls.buffer.pc;</span><br style="font-style:
        italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; /* Begin
        sampling */</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        tls.header.time_begin = OpenSS_GetTime();</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        OpenSS_Timer(tls.data.interval, exampleTimerHandler);</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">}</span></small><br>
    <a href="index.html#Collector_Runtime_-_ServerVictim_"><small>Back
        To Collector Runtime - Server/Victim portion of Experiment
        Collector</small></a><br>
    <br>
    <h5><a class="mozTocH5" name="mozTocId999542"></a><a
        name="Stop_Sampling"></a>Stop Sampling</h5>
    <small><span style="font-style: italic;">/**</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* Stop sampling.</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;*</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* Stops program counter
        (PC) sampling for the thread executing this function.</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* Disables the sampling
        timer and sends any samples remaining in the buffer.</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;*</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* @param
        arguments&nbsp;&nbsp;&nbsp; Encoded (unused) function arguments.</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;*/</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">void example_stop_sampling(const
        char* arguments)</span><br style="font-style: italic;">
      <span style="font-style: italic;">{</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; /* Stop
        sampling */</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        OpenSS_Timer(0, NULL);</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        tls.header.time_end = OpenSS_GetTime();</span><br
        style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; /* Send any
        samples remaining in the sample buffer */</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        if(tls.data.pc.pc_len &gt; 0)</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        OpenSS_Send(&amp;(tls.header), (xdrproc_t)xdr_example_data,
        &amp;(tls.data));</span><br style="font-style: italic;">
      <span style="font-style: italic;">}</span></small><br>
    <a href="index.html#Collector_Runtime_-_ServerVictim_"><small>Back
        To Collector Runtime - Server/Victim portion of Experiment
        Collector</small></a><br>
    <br>
    <br>
    <h5><a class="mozTocH4" name="mozTocId40824"></a>Framework runtime</h5>
    The framework runtime contains a number of routines that the
    experiment collector can use.&nbsp;&nbsp; The libopenss-runtime
    Open|SpeedShop source directory contains the source for these
    supporting routines.&nbsp;&nbsp; Routines available in this
    directory provide this functionality:<br>
    <ul>
      <li>Decoding the data blobs via XDR translation</li>
      <li>Open|SpeedShop timer functions<br>
      </li>
      <li>Send the data blobs from the victim application to the
        Open|SpeedShop client</li>
      <li>Get the program counter address from a given context</li>
      <li>PAPI support functions</li>
      <li>Access to libunwind functionality</li>
    </ul>
    <h4><a class="mozTocH4" name="mozTocId637965"></a><a
        name="Collector_Plugin_-_ClientTool_portion"></a>Collector
      Plugin - Client/Tool portion of Experiment Collector<br>
    </h4>
    The client collector plugin activates the collector runtime by
    directly and indirectly making calls to the collector runtime
    functions.&nbsp;&nbsp;&nbsp; An example user action illustrates the
    path between the client and runtime collector plugin
    functionality.&nbsp;&nbsp; Suppose the user does a user interface
    gesture that tells Open|SpeedShop to start
    collecting.&nbsp;&nbsp;&nbsp; This triggers the user interface to
    call the Open|SpeedShop framework which then accesses the
    start_collecting function in the client collector
    plugin.&nbsp;&nbsp; The client collector plugin calls an
    Open|SpeedShop routine which ultimately triggers the start
    collecting function in the runtime collector plugin.<br>
    <br>
    <div style="margin-left: 40px;"><img alt="Start Collection
        Illustration" src="ToolStartCollectingView.png" style="width:
        696px; height: 342px;"><br>
    </div>
    <h4><a class="mozTocH4" name="mozTocId775061"></a>Collector Plugin
      API- Public Member Functions </h4>
    There are six functions which form the basis for the collector and
    must be defined in every collector plugin.&nbsp;&nbsp; The six
    functions make up the public member functions for collector plugin
    API and perform the following tasks: <br>
    <ul>
      <li>Start Collecting Experiment Performance data (metrics)<br>
      </li>
      <li>Stop Collecting</li>
      <li>Get the Collector's Metric Values</li>
      <li>Set the Collector Parameter</li>
      <li>Get the Collector's Default Parameters</li>
      <li>Get the Collector's Parameter(s)</li>
    </ul>
    These public functions make use of the collector plugin private
    member functions.&nbsp;&nbsp; The following sub-sections describe
    the public member functions.&nbsp;&nbsp; See <a
      href="#Collector_Plugin_API_-_Protected_Member">Collector Plugin
      API - Private Member Functions</a> for details.<br>
    <h5><a class="mozTocH5" name="mozTocId388988"></a><big><big><small>The
Start
Collecting

            function</small><br>
        </big></big></h5>
    <h6><a class="mozTocH6" name="mozTocId199690"></a><b><big><b>What it
            does:</b></big></b></h6>
    Start data collection function implements starting data collection
    for a particular thread.<br>
    <h6><a class="mozTocH6" name="mozTocId219262"></a><b><big><b>Definition:</b></big></b></h6>
    This is an example definition from the Open|SpeedShop Usertime
    Collector Plugin:<br>
    <span style="font-style: italic;">void
      ExampleCollector::startCollecting (const Collector &amp;
      collector,</span><br style="font-style: italic;">
    <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
Thread

      &amp; thread ) const</span><br>
    <p></p>
    <h6><a class="mozTocH6" name="mozTocId347609"></a><big><b>Parameters:</b></big></h6>
    <dl compact="compact">
      <dt>The meaning or definitions for the arguments above are
        summarized here:<span style="font-weight: bold;"></span></dt>
    </dl>
    <ol>
      <li>collector - The collector that will be starting data
        collection</li>
      <li>thread - The thread for which to start data collection.<br>
      </li>
    </ol>
    <h6><a class="mozTocH6" name="mozTocId50896"></a><big><b>What's
          needed in the function body:</b></big></h6>
    <ol>
      <li>Assemble and encode collector arguments to the collectors
        start collecting routine.</li>
      <li>Make decision on where to insert your instrumentation code
        (performance data gathering code).&nbsp; The options are:<br>
      </li>
      <ul>
        <li>Execute this function now</li>
        <li>Execute at entry to a function</li>
        <li>Execute at exit of a function</li>
        <li>Execute another function in place of a specified function<br>
        </li>
      </ul>
      <li>Insert instrumentation to:</li>
    </ol>
    <ul style="margin-left: 40px;">
      <li>Execute collector's stop_sampling routine when we enter exit()
        for the thread.</li>
      <li>Execute collector's start_sampling routine in the thread</li>
    </ul>
    <h6><a class="mozTocH6" name="mozTocId628096"></a><big><a
          name="Example_Collector_Code_Example:"></a>Example Collector
        Code Example:</big><br>
    </h6>
    <small style="font-style: italic;"> /**<br>
      &nbsp;* Start data collection.<br>
      &nbsp;*<br>
      &nbsp;* Implement starting data collection for a particular
      thread.<br>
      &nbsp;*<br>
      &nbsp;* @param collector&nbsp;&nbsp;&nbsp; Collector starting data
      collection.<br>
      &nbsp;* @param thread&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread
      for which to start collecting data.<br>
      &nbsp;*/<br>
      void ExampleCollector::startCollecting(const Collector&amp;
      collector,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
Thread&amp;

      thread) const<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // Assemble and encode arguments to
      example_start_sampling()<br>
      &nbsp;&nbsp;&nbsp; example_start_sampling_args args;<br>
      &nbsp;&nbsp;&nbsp; memset(&amp;args, 0, sizeof(args));<br>
      &nbsp;&nbsp;&nbsp; collector.getParameterValue("sampling_rate",
      args.sampling_rate);<br>
      &nbsp;&nbsp;&nbsp; getECT(collector, thread, args.experiment,
      args.collector, args.thread);<br>
      &nbsp;&nbsp;&nbsp; Blob
arguments(reinterpret_cast&lt;xdrproc_t&gt;(xdr_example_start_sampling_args),<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

      &amp;args);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // Execute example_stop_sampling() when we
      enter exit() for the thread<br>
      &nbsp;&nbsp;&nbsp; executeAtEntry(collector, thread,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"exit",
"example-rt:

      example_stop_sampling", Blob());<br>
      <br>
      &nbsp;&nbsp;&nbsp; // Execute example_start_sampling() in the
      thread<br>
      &nbsp;&nbsp;&nbsp; executeNow(collector, thread,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"example-rt:
example_start_sampling",

      arguments);<br>
      }</small><br>
    <h5><a class="mozTocH5" name="mozTocId992246"></a><big><big><small>The
Stop
Collecting

            function</small><br>
        </big></big></h5>
    <h6><a class="mozTocH6" name="mozTocId150755"></a><big><b>What it
          does:</b></big></h6>
    Stop data collection function implements stopping data collection
    for a particular thread.<br>
    <h6><a class="mozTocH6" name="mozTocId352197"></a><big><b>Definition:</b></big></h6>
    This is an example definition from the Open|SpeedShop Example
    Collector Plugin:<br>
    <span style="font-style: italic;">void
      ExampleCollector::stopCollecting (const Collector &amp; collector,</span><br
      style="font-style: italic;">
    <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
Thread

      &amp; thread ) const</span><br>
    <p></p>
    <h6><a class="mozTocH6" name="mozTocId139139"></a><big><b>Parameters:</b></big></h6>
    <dl compact="compact">
      <dt>The meaning or definitions for the arguments above are
        summarized here:<span style="font-weight: bold;"></span></dt>
    </dl>
    <ol>
      <li>collector - The collector that will be stopping data
        collection</li>
      <li>thread - The thread for which to stop data collection.<br>
      </li>
    </ol>
    <h6><a class="mozTocH6" name="mozTocId722160"></a><big><b>Decisions
          and what's needed in the function body:</b></big></h6>
    The primary tasks of this function that need to be done are:
    <ol>
      <li>Insert instrumentation to execute the collector's
        stop_sampling routine in the thread<br>
      </li>
      <li>Remove the instrumentation that was inserted by
        startCollecting:</li>
    </ol>
    <ul style="margin-left: 40px;">
      <li>Execute collector's stop_sampling routine when we enter exit()
        for the thread.</li>
      <li>Execute collector's start_sampling routine in the thread</li>
    </ul>
    <br>
    <h6><a class="mozTocH6" name="mozTocId499496"></a><big><b><big><b><a
                name="Example_collectory_code_example:"></a><small>Example

                collector code example:</small></b></big></b></big></h6>
    <small><span style="font-style: italic;">/**</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* Stops data collection.</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;*</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* Implement stopping data
        collection for a particular thread.</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;*</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* @param
        collector&nbsp;&nbsp;&nbsp; Collector stopping data collection.</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* @param
        thread&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread for which to
        stop collecting data.</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;*/</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">void
        ExampleCollector::stopCollecting(const Collector&amp; collector,</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
Thread&amp;

        thread) const</span><br style="font-style: italic;">
      <span style="font-style: italic;">{</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; // Execute
        example_stop_sampling() in the thread</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        executeNow(collector, thread,</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"example-rt:
example_stop_sampling",

        Blob());</span><br style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; // Remove all
        instrumentation associated with this collector/thread pairing</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        uninstrument(collector, thread);</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">}</span></small><br>
    <small></small>
    <h5><a class="mozTocH5" name="mozTocId278716"></a><big><small>The
          Get Metric Values function</small><br>
      </big></h5>
    <h6><a class="mozTocH6" name="mozTocId110227"></a><big><b>What it
          does:</b></big></h6>
    This routine is used by the Open|SpeedShop framework to get the
    metrics for each data blob the framework processes.&nbsp; The
    framework will first query for address range extents and then calls
    the collector plugin (getMetricValues) once for each data
    blob.&nbsp;&nbsp; Extents are defined as a set of address ranges and
    a time interval.&nbsp;&nbsp; For example, an address range could be
    the addresses in the function "xyz" and the time interval could be
    the entire running time of the program.<br>
    <h6><a class="mozTocH6" name="mozTocId171646"></a><big><b>Definition:</b></big></h6>
    This is an example definition from the Open|SpeedShop Example
    Collector Plugin:<br>
    <span style="font-style: italic;">void
      ExampleCollector::getMetricValues(const std::string&amp; metric,</span><br
      style="font-style: italic;">
    <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
Extent&amp;

      extent,</span><br style="font-style: italic;">
    <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
Blob&amp;

      blob,</span><br style="font-style: italic;">
    <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
ExtentGroup&amp;

      subextents,</span><br style="font-style: italic;">
    <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
void*
ptr)

      const<br>
    </span>
    <h6><a class="mozTocH6" name="mozTocId530275"></a><big><b>Parameters:</b></big></h6>
    The meaning or definitions for the arguments above are summarized
    here:<br>
    <ol>
      <li>metric - Unique identifier of the metric</li>
      <li>extent - Extent of the performance data blob</li>
      <li>blob - Blob containing the performance data</li>
      <li>subextents - The subextents for which to get the values</li>
      <li>ptr&nbsp; - Untyped pointer to the return values.</li>
    </ol>
    <h6><a class="mozTocH6" name="mozTocId673416"></a><big><b>Decisions
          and what's needed in the function body:</b></big></h6>
    The primary tasks of this function that need to be done are:<br>
    <ol>
      <li>Process the collector's metric value(s) by iterating over the
        blob containing the raw performance data.</li>
      <ul>
        <li>Check input parameters for validity</li>
        <li>Decode the data blob using XDR</li>
        <li>Using subextents to find out if there are metrics to return
          by iterating over the samples in the data blob</li>
        <li>Do collector specific calculations for time, event counts,
          or other</li>
      </ul>
      <li>Free the decoded performance data blob.</li>
    </ol>
    <h6><a class="mozTocH6" name="mozTocId435581"></a><small><small><b><big><b><big><b><big><b><a
                          name="Example_collectory_code_example:_"></a>Example

                        collector code example:</b></big></b></big></b></big></b></small></small></h6>
    <small><span style="font-style: italic;">/**</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* Get metric values.</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;*</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* Implements getting one
        of this collector's metric values over all subextents</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* of the specified extent
        for a particular thread, for one of the collected</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* performance data blobs.</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;*</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* @param
        metric&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Unique
        identifier of the metric.</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* @param
        collector&nbsp;&nbsp;&nbsp;&nbsp; Collector for which to get
        values.</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* @param
        thread&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread for
        which to get values.</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* @param
        extent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Extent of the
        performance data blob.</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* @param
        blob&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Blob
        containing the performance data.</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;* @param
        subextents&nbsp;&nbsp;&nbsp; Subextents for which to get values.</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* @retval
        ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Untyped pointer to the values of the metric.</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;*/</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">void
        ExampleCollector::getMetricValues(const std::string&amp; metric,</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
Collector&amp;

        collector,</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
Thread&amp;

        thread,</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
Extent&amp;

        extent,</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
Blob&amp;

        blob,</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
ExtentGroup&amp;

        subextents,</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
void*
ptr)

        const</span><br style="font-style: italic;">
      <span style="font-style: italic;">{</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; // Only the
        "time" metric returns anything</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; if(metric !=
        "time")</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        return;</span><br style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; // Cast the
        untyped pointer into a vector of doubles</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        std::vector&lt;double&gt;* values =
        reinterpret_cast&lt;std::vector&lt;double&gt;*&gt;(ptr);</span><br
        style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; // Check
        assertions</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        Assert(values-&gt;size() &gt;= subextents.size());</span><br
        style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; // Decode
        this data blob</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; example_data
        data;</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        memset(&amp;data, 0, sizeof(data));</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        blob.getXDRDecoding(reinterpret_cast&lt;xdrproc_t&gt;(xdr_example_data),

        &amp;data);</span><br style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; // Calculate
        the time (in seconds) attributable to each sample</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; double
        t_sample =</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
static_cast&lt;double&gt;(data.interval)
/

        1000000000.0;</span><br style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; // Calculate
        time (in nS) of data blob's extent</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; double t_blob
        =</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        static_cast&lt;double&gt;(extent.getTimeInterval().getWidth());</span><br
        style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; // Iterate
        over each of the samples</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; for(unsigned
        i = 0; i &lt; data.pc.pc_len; ++i) {</span><br
        style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
Find

        the subextents that contain this sample</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
std::set&lt;ExtentGroup::size_type&gt;
intersection

        =</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        subextents.getIntersectionWith(</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        Extent(extent.getTimeInterval(),</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        AddressRange(data.pc.pc_val[i]))</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        );</span><br style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
Iterate

        over each subextent in the intersection</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        for(std::set&lt;ExtentGroup::size_type&gt;::const_iterator</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
j
=

        intersection.begin(); j != intersection.end(); ++j) {</span><br
        style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
Calculate

        intersection time (in nS) of subextent and data blob</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
double
t_intersection

        = static_cast&lt;double&gt;</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        ((extent.getTimeInterval() &amp;</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        subextents[*j].getTimeInterval()).getWidth());</span><br
        style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
Add

        (to the subextent's metric value) the appropriate fraction</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
of

        the total time attributable to this sample</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(*values)[*j]
+=

        t_sample * (t_intersection / t_blob);</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        }</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; }</span><br
        style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; // Free the
        decoded data blob</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        xdr_free(reinterpret_cast&lt;xdrproc_t&gt;(xdr_example_data),</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        reinterpret_cast&lt;char*&gt;(&amp;data));</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">}</span></small><br>
    <h5><a class="mozTocH5" name="mozTocId271962"></a><big><big><small><small>The

              Set Parameter function</small></small><br>
        </big></big></h5>
    <h6><a class="mozTocH6" name="mozTocId753822"></a><big><b>What it
          does:</b></big></h6>
    <p>The set a parameter function is responsible for setting one of
      the collector parameter values.<br>
    </p>
    <h6><a class="mozTocH6" name="mozTocId163320"></a><big><b>Definition:</b></big><br>
    </h6>
    <p>This is an example definition from the Open|SpeedShop Example
      Collector Plugin:<br>
      <span style="font-style: italic;">void
        ExampleCollector::setParameterValue(const std::string&amp;
        parameter,</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
void*

        ptr, </span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Blob&amp;
data)

        const</span><br>
    </p>
    <p></p>
    <h6><a class="mozTocH6" name="mozTocId699056"></a><small> </small><big><b>Parameters:</b></big></h6>
    <ol>
      <li>parameter - Unique identifier of the input parameter to be set</li>
      <li>ptr - Untyped pointer to the parameter value</li>
    </ol>
    <h6><a class="mozTocH6" name="mozTocId97265"></a><small> </small><big><b>Return

          values:</b></big></h6>
    <ol>
      <li>data - blob containing the parameter values for the collector</li>
    </ol>
    <h6><a class="mozTocH6" name="mozTocId259611"></a><big><b>Decisions
          and what's needed in the function body:</b></big></h6>
    The primary tasks of this function that need to be done are:<br>
    <ol>
      <li>Decode the blob containing the parameter values</li>
      <li>Set the "collector specific" parameter based on the input</li>
      <li>Re-encode the blob containing the parameter values</li>
    </ol>
    <h6><a class="mozTocH6" name="mozTocId999507"></a><small><small><small><small><b><big><b><big><b><big><b><small><small><b><big><b><big><b><big><b><a
name="Example_collector_code_example:"></a><big>Example collector code
                                                example:</big></b></big></b></big></b></big></b></small></small></b></big></b></big></b></big></b></small></small></small></small></h6>
    <small style="font-style: italic;">/**<br>
      &nbsp;* Set a parameter value.<br>
      &nbsp;*<br>
      &nbsp;* Implements setting one of our parameter values.<br>
      &nbsp;*<br>
      &nbsp;* @param parameter&nbsp;&nbsp;&nbsp; Unique identifier of
      the parameter.<br>
      &nbsp;* @param
      ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Untyped
      pointer to the parameter value.<br>
      &nbsp;* @retval data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      Blob containing the parameter values.<br>
      &nbsp;*/<br>
      void ExampleCollector::setParameterValue(const std::string&amp;
      parameter,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
void*

      ptr, Blob&amp; data) const<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // Decode the blob containing the parameter
      values<br>
      &nbsp;&nbsp;&nbsp; example_parameters parameters;<br>
      &nbsp;&nbsp;&nbsp; memset(&amp;parameters, 0, sizeof(parameters));<br>
      &nbsp;&nbsp;&nbsp;
data.getXDRDecoding(reinterpret_cast&lt;xdrproc_t&gt;(xdr_example_parameters),<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

      &amp;parameters);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // Handle the "sampling_rate" parameter<br>
      &nbsp;&nbsp;&nbsp; if(parameter == "sampling_rate") {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned* value =
      reinterpret_cast&lt;const unsigned*&gt;(ptr);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      parameters.sampling_rate = *value;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp;&nbsp; // Re-encode the blob containing the parameter
      values<br>
      &nbsp;&nbsp;&nbsp; data =
      Blob(reinterpret_cast&lt;xdrproc_t&gt;(xdr_example_parameters),<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

      &amp;parameters);<br>
      }</small><br>
    <h5><a class="mozTocH5" name="mozTocId518369"></a><big><big><small><small>The

              Get Default Parameters function</small></small><br>
        </big></big></h5>
    <h6><a class="mozTocH6" name="mozTocId709984"></a><big><b>What it
          does:</b></big></h6>
    The get default parameters function implements getting the default
    parameter set for the collector.<br>
    <h6><a class="mozTocH6" name="mozTocId832976"></a><big><b>Definition:</b></big></h6>
    This is an example definition from the Open|SpeedShop Example
    Collector Plugin:<br>
    <div style="text-align: left;"><span style="font-style: italic;">Blob
ExampleCollector::getDefaultParameterValues()

        const</span><br style="font-style: italic;">
    </div>
    <h6><a class="mozTocH6" name="mozTocId646706"></a><big><b>Return
          values:</b></big></h6>
    <ol>
      <li>data - Blob containing the default parameter values.</li>
    </ol>
    <h6><a class="mozTocH6" name="mozTocId15384"></a><big><b>Decisions
          and what's needed in the function body:</b></big></h6>
    The primary tasks of this function that need to be done are:<br>
    <ol>
      <li>Setup an empty parameter structure</li>
      <li>Set the default parameters </li>
      <li>Return the encoded blob to the caller</li>
    </ol>
    <h6><a class="mozTocH6" name="mozTocId207187"></a><small><small><small><small><b><big><b><big><b><big><b><small><small><b><big><b><big><b><big><b><small><small><small><small><b><big><b><big><b><big><b><small><small><b><big><b><big><b><big><b><a
name="Example_collector_code_example:_"></a><big>Example collector code
                                                          example:</big></b></big></b></big></b></big></b></small></small></b></big></b></big></b></big></b></small></small></small></small></b></big></b></big></b></big></b></small></small></b></big></b></big></b></big></b></small></small></small></small></h6>
    <small style="font-style: italic;">/**<br>
      &nbsp;* Get the default parameter values.<br>
      &nbsp;*<br>
      &nbsp;* Implement getting our default parameter values.<br>
      &nbsp;*<br>
      &nbsp;* @return&nbsp;&nbsp;&nbsp; Blob containing the default
      parameter values.<br>
      &nbsp;*/<br>
      Blob ExampleCollector::getDefaultParameterValues() const<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // Setup an empty parameter structure<br>
      &nbsp;&nbsp;&nbsp; example_parameters parameters;<br>
      &nbsp;&nbsp;&nbsp; memset(&amp;parameters, 0, sizeof(parameters));<br>
      <br>
      &nbsp;&nbsp;&nbsp; // Set the default parameters<br>
      &nbsp;&nbsp;&nbsp; parameters.sampling_rate = 100;<br>
      <br>
      &nbsp;&nbsp;&nbsp; // Return the encoded blob to the caller<br>
      &nbsp;&nbsp;&nbsp; return
      Blob(reinterpret_cast&lt;xdrproc_t&gt;(xdr_example_parameters),<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

      &amp;parameters);<br>
      }</small><br>
    <h5><a class="mozTocH5" name="mozTocId769605"></a><big><small>The
          Get Parameters function</small><br>
      </big></h5>
    <h6><a class="mozTocH6" name="mozTocId340210"></a><big><b>What it
          does:</b></big></h6>
    The get a parameter function implements getting one of the collector
    parameter values.<br>
    <h6><a class="mozTocH6" name="mozTocId552888"></a><big><b>Definition:</b></big></h6>
    This is an example definition from the Open|SpeedShop Example
    Collector Plugin:<br>
    void ExampleCollector::getParameterValue(const std::string&amp;
    parameter,<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
const
Blob&amp;

    data, void* ptr) const<br>
    <h6><a class="mozTocH6" name="mozTocId731991"></a><big><b>Parameters:</b></big></h6>
    <ol>
      <li>parameter - Unique identifier of the input parameter to be
        get.</li>
      <li>data - blob containing the parameter values for the collector</li>
    </ol>
    <h6><a class="mozTocH6" name="mozTocId705614"></a><big><b>Return
          values:</b></big></h6>
    <ol>
      <li>ptr - Untyped pointer to the parameter value</li>
    </ol>
    <h6><a class="mozTocH6" name="mozTocId196328"></a><big><b>Decisions
          and what's needed in the function body:</b></big></h6>
    <small><b> </b></small>
    <ol>
      <li>Decode the data blob containing the parameter values using XDR
        (External Data Representation)</li>
      <li>Extract the parameter value from the decoded parameter value
        data blob</li>
    </ol>
    <h6><a class="mozTocH6" name="mozTocId334143"></a><small><small><small><small><b><big><b><big><b><big><b><small><small><b><big><b><big><b><big><b><small><small><small><small><b><big><b><big><b><big><b><small><small><b><big><b><big><b><big><b><small><small><small><small><b><big><b><big><b><big><b><small><small><b><big><b><big><b><big><b><small><small><small><small><b><big><b><big><b><big><b><small><small><b><big><b><big><b><big><b><a
name="Example_collector_code_example-getp"></a><big>Example collector
                                                          code example:</big></b></big></b></big></b></big></b></small></small></b></big></b></big></b></big></b></small></small></small></small></b></big></b></big></b></big></b></small></small></b></big></b></big></b></big></b></small></small></small></small></b></big></b></big></b></big></b></small></small></b></big></b></big></b></big></b></small></small></small></small></b></big></b></big></b></big></b></small></small></b></big></b></big></b></big></b></small></small></small></small></h6>
    <small style="font-style: italic;">/**<br>
      &nbsp;* Get a parameter value.<br>
      &nbsp;*<br>
      &nbsp;* Implement getting one of our parameter values.<br>
      &nbsp;*<br>
      &nbsp;* @param parameter&nbsp;&nbsp;&nbsp; Unique identifier of
      the parameter.<br>
      &nbsp;* @param
      data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Blob
      containing the parameter values.<br>
      &nbsp;* @retval
      ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Untyped
      pointer to the parameter value.<br>
      &nbsp;*/<br>
      void ExampleCollector::getParameterValue(const std::string&amp;
      parameter,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;
&nbsp;

      &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
      &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
      &nbsp;&nbsp; const Blob&amp; data, void* ptr) const<br>
      {<br>
      &nbsp;&nbsp;&nbsp; // Decode the blob containing the parameter
      values<br>
      &nbsp;&nbsp;&nbsp; example_parameters parameters;<br>
      &nbsp;&nbsp;&nbsp; memset(&amp;parameters, 0, sizeof(parameters));<br>
      &nbsp;&nbsp;&nbsp;
data.getXDRDecoding(reinterpret_cast&lt;xdrproc_t&gt;(xdr_example_parameters),<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

      &amp;parameters);<br>
      <br>
      &nbsp;&nbsp;&nbsp; // Handle the "sampling_rate" parameter<br>
      &nbsp;&nbsp;&nbsp; if(parameter == "sampling_rate") {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned* value =
      reinterpret_cast&lt;unsigned*&gt;(ptr);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *value =
      parameters.sampling_rate;<br>
      &nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
    </small>
    <h4><a class="mozTocH4" name="mozTocId761089"></a><a
        name="Collector_Plugin_API_-_Protected_Member"></a>Collector
      Plugin API - Protected Member Functions</h4>
    These are the functions that the collector writer uses to implement
    the runtime/victim portion of the experiment data collector
    plugin.&nbsp; They are implemented in the Open|SpeedShop framework
    library.&nbsp;&nbsp; The source can be found in
    "&lt;top_srcdir&gt;/libopenss-framework/CollectorImpl.cxx".<br>
    <br>
    <h5><a class="mozTocH5" name="mozTocId237373"></a>Collector
      Implementation Constructor</h5>
    <h6><a class="mozTocH6" name="mozTocId876077"></a>Definition</h6>
    &nbsp;&nbsp;&nbsp;&nbsp; CollectorImpl (const std::string &amp;,
    const std::string &amp;, const std::string &amp;)<br>
    <h6><a class="mozTocH6" name="mozTocId610118"></a>What it does, when
      it can be used, and example usage code</h6>
    Constructs a collector implementation with the given metadata.&nbsp;
    <br>
    <br>
    <small><span style="font-style: italic;">/**</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* Default constructor.</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;*</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* Constructs a new example
        collector with the proper metadata.</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;*/</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">ExampleCollector::ExampleCollector()

        :</span><br style="font-style: italic;">
      <span style="font-style: italic; font-weight: bold;">&nbsp;&nbsp;&nbsp;

        CollectorImpl("example",</span><br style="font-style: italic;
        font-weight: bold;">
      <span style="font-style: italic; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        "Example",</span><br style="font-style: italic; font-weight:
        bold;">
      <span style="font-style: italic; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Simple
example

        performance data collector illustrating the "</span><br
        style="font-style: italic; font-weight: bold;">
      <span style="font-style: italic; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"basics
of

        the Collector API. Periodically interrupts the "</span><br
        style="font-style: italic; font-weight: bold;">
      <span style="font-style: italic; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"running
thread,

        obtains the current program counter (PC) "</span><br
        style="font-style: italic; font-weight: bold;">
      <span style="font-style: italic; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"value,
stores

        it, and allows the thread to continue "</span><br
        style="font-style: italic; font-weight: bold;">
      <span style="font-style: italic; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        "execution.")</span><br style="font-style: italic;">
      <span style="font-style: italic;">{</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; // Declare
        our parameters</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        declareParameter(Metadata("sampling_rate", "Sampling Rate",</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Sampling
rate

        in samples/seconds.",</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        typeid(unsigned)));</span><br style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic; font-weight: bold;">&nbsp;&nbsp;&nbsp;

      </span><span style="font-style: italic;">// Declare our metrics</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        declareMetric(Metadata("time", "CPU Time",</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Exclusive
CPU

        time in seconds.",</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        typeid(double)));</span><br style="font-style: italic;">
      <span style="font-style: italic;">}</span></small><br>
    <h5><a class="mozTocH5" name="mozTocId778216"></a>Declare a
      Parameter</h5>
    <h6><a class="mozTocH6" name="mozTocId399016"></a>Definition</h6>
    void &nbsp;&nbsp;&nbsp; declareParameter (const Metadata &amp;)<br>
    <h6><a class="mozTocH6" name="mozTocId654759"></a>What it does, when
      it can be used, and example usage code</h6>
    Declares a parameter by adding it to this collector implementation
    and is called by a collector when declaring the parameter for the
    particular collector.&nbsp; The call to declareParameter is usually
    made from collector's constructor. &nbsp;&nbsp; Here is the a code
    snippet from the example collector found in
"&lt;top_srcdir&gt;/examples/libopenss-framework/collector/ExampleCollector.cxx".<br>
    <br>
    <small><span style="font-style: italic;">/**</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* Default constructor.</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;*</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* Constructs a new example
        collector with the proper metadata.</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;*/</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">ExampleCollector::ExampleCollector()

        :</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        CollectorImpl("example",</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        "Example",</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Simple
example

        performance data collector illustrating the "</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"basics
of

        the Collector API. Periodically interrupts the "</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"running
thread,

        obtains the current program counter (PC) "</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"value,
stores

        it, and allows the thread to continue "</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        "execution.")</span><br style="font-style: italic;">
      <span style="font-style: italic;">{</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;<span
          style="font-weight: bold;">&nbsp; // Declare our parameters</span></span><br
        style="font-style: italic; font-weight: bold;">
      <span style="font-style: italic; font-weight: bold;">&nbsp;&nbsp;&nbsp;
declareParameter(Metadata("sampling_rate",

        "Sampling Rate",</span><br style="font-style: italic;
        font-weight: bold;">
      <span style="font-style: italic; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Sampling
rate

        in samples/seconds.",</span><br style="font-style: italic;
        font-weight: bold;">
      <span style="font-style: italic; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        typeid(unsigned)));</span><br style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; // Declare
        our metrics</span><br style="font-style: italic; font-weight:
        bold;">
      <span style="font-style: italic; font-weight: bold;">&nbsp;&nbsp;</span><span
        style="font-style: italic;">&nbsp;
        declareMetric(Metadata("time", "CPU Time",</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Exclusive
CPU

        time in seconds.",</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        typeid(double)));</span><br style="font-style: italic;
        font-weight: bold;">
      <span style="font-style: italic;">}</span> </small><br>
    <h6><a class="mozTocH6" name="mozTocId373057"></a>Parameters</h6>
    <div style="margin-left: 40px;">Metadata&nbsp; - &nbsp; Declares the
      properties of the parameter to be used by the collector.<br>
      <br>
      Metadata general description:<br>
      Container storing object metadata consisting of a unique
      identifier, short name, verbose description, and underlying type.
      These properties are assigned when the Metadata object is created.
      Member functions for querying these properties are
      defined.&nbsp;&nbsp; Metadata objects are defined as being
      equivalent when their unique identifiers are
      identical.&nbsp;&nbsp; Used for describing collectors, their
      parameters, and their metrics.<br>
    </div>
    <small style="font-style: italic;"><br>
    </small>
    <h6><a class="mozTocH6" name="mozTocId722064"></a><span
        class="mozTocH6"></span>Return Values</h6>
    <div style="margin-left: 40px;">None.<br>
    </div>
    <h5><a class="mozTocH5" name="mozTocId957175"></a>Declare a Metric</h5>
    <h6><a class="mozTocH6" name="mozTocId684094"></a>Definition</h6>
    <small style="font-style: italic;">void &nbsp;&nbsp;&nbsp;
      declareMetric (const Metadata &amp;)</small><br>
    <h6><a class="mozTocH6" name="mozTocId626761"></a><a
        name="What_it_does_when_it_can_be_used_and"></a>What it does,
      when it can be used, and example usage code<br>
    </h6>
    Declares a metric by adding it to this collector implementation and
    is called by a collector when declaring the metric for the
    particular collector.&nbsp; The call to declareMetric is usually
    made from collector's constructor. &nbsp;&nbsp; Here is the a code
    snippet from the example collector found in
"&lt;top_srcdir&gt;/examples/libopenss-framework/collector/ExampleCollector.cxx".<br>
    <br>
    <small><span style="font-style: italic;">/**</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* Default constructor.</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;*</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;* Constructs a new example
        collector with the proper metadata.</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;*/</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">ExampleCollector::ExampleCollector()

        :</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        CollectorImpl("example",</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        "Example",</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Simple
example

        performance data collector illustrating the "</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"basics
of

        the Collector API. Periodically interrupts the "</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"running
thread,

        obtains the current program counter (PC) "</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"value,
stores

        it, and allows the thread to continue "</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        "execution.")</span><br style="font-style: italic;">
      <span style="font-style: italic;">{</span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp; // Declare
        our parameters</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
        declareParameter(Metadata("sampling_rate", "Sampling Rate",</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Sampling
rate

        in samples/seconds.",</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        typeid(unsigned)));</span><br style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic; font-weight: bold;">&nbsp;&nbsp;&nbsp;
//

        Declare our metrics</span><br style="font-style: italic;
        font-weight: bold;">
      <span style="font-style: italic; font-weight: bold;">&nbsp;&nbsp;&nbsp;
declareMetric(Metadata("time",

        "CPU Time",</span><br style="font-style: italic; font-weight:
        bold;">
      <span style="font-style: italic; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Exclusive
CPU

        time in seconds.",</span><br style="font-style: italic;
        font-weight: bold;">
      <span style="font-style: italic; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        typeid(double)));</span><br style="font-style: italic;">
      <span style="font-style: italic;">}</span></small><br>
    <h6><a class="mozTocH6" name="mozTocId741847"></a>Parameters</h6>
    <div style="margin-left: 40px;">Metadata&nbsp; - &nbsp; Declares the
      properties of the metric to be gathered by the collector.<br>
      <br>
      Metadata general description:<br>
      Container storing object metadata consisting of a unique
      identifier, short name, verbose description, and underlying type.
      These properties are assigned when the Metadata object is created.
      Member functions for querying these properties are
      defined.&nbsp;&nbsp; Metadata objects are defined as being
      equivalent when their unique identifiers are
      identical.&nbsp;&nbsp; Used for describing collectors, their
      parameters, and their metrics.<br>
    </div>
    <small style="font-style: italic;"><br>
    </small>
    <h6><a class="mozTocH6" name="mozTocId804375"></a>Return Values</h6>
    <div style="margin-left: 40px;">None.<br>
    </div>
    <br>
    <h5><a class="mozTocH5" name="mozTocId501955"></a>Get experiment,
      collector, and thread (ECT) identifiers</h5>
    void &nbsp;&nbsp;&nbsp; getECT (const Collector &amp;, const Thread
    &amp;, int &amp;, int &amp;, int &amp;) const<br>
    &nbsp;&nbsp;&nbsp;&nbsp; Get experiment, collector, and thread (ECT)
    identifiers.<br>
    <h5><a class="mozTocH5" name="mozTocId858260"></a>Execute library
      function now.</h5>
    void &nbsp;&nbsp;&nbsp; executeNow (const Collector &amp;, const
    Thread &amp;, const std::string &amp;, const Blob &amp;) const<br>
    &nbsp;&nbsp;&nbsp;&nbsp; Execute library function now.<br>
    <br>
    <h5><a class="mozTocH5" name="mozTocId657026"></a>Execute library
      function at another function's entry.</h5>
    void &nbsp;&nbsp;&nbsp; executeAtEntry (const Collector &amp;, const
    Thread &amp;, const std::string &amp;, const std::string &amp;,
    const Blob &amp;) const<br>
    &nbsp;&nbsp;&nbsp;&nbsp; Execute library function at another
    function's entry.<br>
    <br>
    <h5><a class="mozTocH5" name="mozTocId194372"></a>Execute library
      function at another function's exit.</h5>
    void &nbsp;&nbsp;&nbsp; executeAtExit (const Collector &amp;, const
    Thread &amp;, const std::string &amp;, const std::string &amp;,
    const Blob &amp;) const<br>
    &nbsp;&nbsp;&nbsp;&nbsp; Execute library function at another
    function's exit.<br>
    <br>
    <h5><a class="mozTocH5" name="mozTocId197213"></a> Execute a library
      function in place of another function.</h5>
    void &nbsp;&nbsp;&nbsp; executeInPlaceOf (const Collector &amp;,
    const Thread &amp;, const std::string &amp;, const std::string
    &amp;) const<br>
    &nbsp;&nbsp;&nbsp;&nbsp; Execute a library function in place of
    another function.<br>
    <br>
    <h5><a class="mozTocH5" name="mozTocId342846"></a>Remove
      instrumentation from a thread</h5>
    void &nbsp;&nbsp;&nbsp; uninstrument (const Collector &amp;, const
    Thread &amp;) const<br>
    &nbsp;&nbsp;&nbsp;&nbsp; Remove instrumentation from a thread. <br>
    <br>
    <h3><a class="mozTocH3" name="mozTocId846999"></a><a
        name="Example_Collector_Plugin"></a>Example Collector Plugin</h3>
    The code for the Example Collector Plugin can be found in the
    &lt;top_srcdir&gt;/examples/libopenss-framework/collector
    directory.&nbsp; The files contained in that directory are outlined
    here:<br>
    <ul>
      <li><span style="font-weight: bold;">runtime.c</span>&nbsp;&nbsp;
        - Contains code responsible for gathering the performance
        information from the victim application</li>
    </ul>
    <div style="margin-left: 40px;">See the section describing the <a
        href="#Collector_Runtime_-_ServerVictim_">Collector runtime</a>
      for how to implement the necessary functions for runtime.c.<br>
    </div>
    <ul>
      <li><span style="font-weight: bold;">Makefile.am</span>&nbsp; -
        Has the makefile definitions to compile and create the two
        dynamic shared objects representing the experiment collector
        plugin</li>
    </ul>
    <div style="margin-left: 40px;">Use this file as guide to create the
      new collector plugin.<br>
    </div>
    <ul>
      <li><span style="font-weight: bold;">ExampleCollector.cxx</span>&nbsp;
-&nbsp;
Contains

        code that is used on the client side to decode the data blobs,
        control collecting, and manage parameters.&nbsp;&nbsp; This file
        also contains the collector's factory method that is the key to
        plugin recognition.<br>
      </li>
      <li><span style="font-weight: bold;">ExampleCollector.hxx </span>-
        Header file for ExampleCollector.cxx</li>
    </ul>
    <div style="margin-left: 40px;">See the section describing the <a
        href="#Collector_Plugin_-_ClientTool_portion">Collector Plugin
        (client)</a> for how to implement the necessary functions for
      the client side of the collector plugin.<br>
    </div>
    <ul>
      <li><span style="font-weight: bold;">blobs.x</span> - Binary Large
        Object definition of the data blob which is the gathered data
        structure definition.&nbsp;&nbsp; rpcgen is run on this file
        creating "C" language data definition and data packaging code.</li>
    </ul>
    <div style="margin-left: 40px;">See the section describing the <a
        href="#Data_blobs">data blob</a> for how to design and implement
      the performance data definitions for the data that the runtime
      collector plugin will send to the Open|SpeedShop client.<br>
      <br>
      <br>
    </div>
    Executing the "make install" make file command in the
    "&lt;top_srcdir&gt;/examples/libopenss-framework/collector"
    directory will install the example plugin to the default plugin
    installation path, which is &lt;top_srcdir&gt;../lib/openspeedshop
    or to "$OPENSS_PREFIX/lib/openspeedshop".&nbsp;&nbsp; After the
    example collector plugin is installed, the Open|SpeedShop tool
    recognizes it's presence and it can be used as a
    collector.&nbsp;&nbsp; <br>
    <br>
    The example tool does pcsampling, but all the hashing and any extra
    code that might make it more complicated has been taken out so that
    only the basic plugin functionality is present.&nbsp;&nbsp; For this
    run, the example plugin was installed into the default plugin
    directory and used in the same manner as any other
    plugin.&nbsp;&nbsp; This is the example plugin experiment output:<br>
    <br>
    orbit20-169&gt;pwd<br>
    /home/jeg/openss/current/test/executables/fred<br>
    orbit20-170&gt;<b>openss -cli</b><br>
    Welcome to Open|SpeedShop, version 0.1.<br>
    Type 'help' for more information.<br>
    # Create an interactive command line interface experiment on the
    executable "fred" using the "example" collector<br>
    openss&gt;&gt;<b>expcreate -f fred example</b><br>
    &nbsp;&nbsp; Found symtab<br>
    The new focused experiment identifier is:&nbsp; -x 1<br>
    # Run the focused experiment asynchroniously<br>
    openss&gt;&gt;<small><b><big>expgo</big></b></small><br>
    Start asynchronous execution of experiment:&nbsp; -x 1<br>
    openss&gt;&gt;<br>
    # Give me status of the focused experiment<br>
    openss&gt;&gt;<b>expstatus</b><br>
    Experiment definition<br>
    { # ExpId is 1, Status is Running, Temporary database is
    /tmp/ssdb1DthPUP.openss<br>
    &nbsp; Currently Specified Components:<br>
    &nbsp;&nbsp;&nbsp; -h orbit20 -p 32414 example<br>
    &nbsp; Metrics:<br>
    &nbsp;&nbsp;&nbsp; example::time<br>
    &nbsp; Parameter Values:<br>
    &nbsp;&nbsp;&nbsp; example::sampling_rate =&nbsp; 100<br>
    &nbsp; Available Views:<br>
    &nbsp;&nbsp;&nbsp; pcsamp<br>
    }<br>
    openss&gt;&gt;<br>
    # Execute a ps in the shell, outside of Open|SpeedShop<br>
    openss&gt;&gt;<b>!ps -u jeg</b><br>
    &nbsp; PID TTY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    TIME CMD<br>
    27766 ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00:00:02 sshd<br>
    27767 pts/0&nbsp;&nbsp;&nbsp; 00:00:00 csh<br>
    31008 ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00:00:00 sshd<br>
    31009 pts/1&nbsp;&nbsp;&nbsp; 00:00:00 csh<br>
    32403 pts/1&nbsp;&nbsp;&nbsp; 00:00:04 openss<br>
    32413 ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00:00:03 dpcld64<br>
    32414 ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00:03:06 fred<br>
    32416 pts/1&nbsp;&nbsp;&nbsp; 00:00:00 openss<br>
    32417 pts/1&nbsp;&nbsp;&nbsp; 00:00:00 ps<br>
    <br>
    openss&gt;&gt;Experiment 1 has terminated.<br>
    # View the results of the focused experiment, using the default view<br>
    openss&gt;&gt;<small><b><big>expview</big></b></small><br>
    <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    CPU Time&nbsp; Function Name<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    141.2500&nbsp; f3(fred: f3.c,2)<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
95.0400&nbsp;
f2(fred:

    f2.c,2)<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
47.5100&nbsp;
f1(fred:

    f1.c,2)<br>
    openss&gt;&gt;<br>
    <br>
    <div style="margin-left: 40px;"></div>
    <h3><a class="mozTocH3" name="mozTocId377373"></a><b style="">Collector
Plugin

        FAQ:<br>
        <span class="moz-txt-citetags"><span style="font-family:
            monospace;"></span></span></b></h3>
    <h4><a class="mozTocH4" name="mozTocId198444"></a><b style="">What
        is blob.x for? What is the significance of the .x suffix?<br>
      </b></h4>
    <div class="Section13">
      <div style="text-align: left;">
        <blockquote><b style=""> </b>"blob.x" contains XDR descriptions
          of the blobs (Binary Large OBjectS) used by the collector. The
          term "blob" is a standard one in relational databases: <b
            style=""><br>
            <a class="moz-txt-link-freetext"
              href="http://www.hyperdictionary.com/dictionary/binary+large+object">http://www.hyperdictionary.com/dictionary/binary+large+object</a><br>
            <br>
          </b>And ".x" is the standard suffix used for XDR files. You
          can do (this is what I<br>
          did) a search for "XDR file suffix" and you'll see that
          everyone uses ".x".<br>
          <br>
          Collector parameters can be of any arbitrary type or
          structure. And the raw data gathered by the collector can be
          of any arbitrary type or structure. But the relational
          database doesn't know anything about these types... So
          whenever<br>
          parameters or raw performance data is stored in the database,
          it must first be converted into a "chunk of bytes" (a blob).
          XDR is added to the mix in order to easily handle things like
          endianess and structure alignment issues. <b style=""><span
              class="moz-txt-citetags"><br>
            </span></b></blockquote>
      </div>
      <h4 style="text-align: left;"><a class="mozTocH4"
          name="mozTocId189119"></a><b style="">What is specifically
          needed to be known by the framework? Do these<span
            class="moz-txt-citetags"> </span>class structures need to
          follow a particular convention?</b></h4>
      <div style="text-align: left;">
        <blockquote> <b style=""> </b><!----> The naming of these
          files (e.g. "blob.x" vs. "my_funny_file_name.x") makes no
          difference to the framework.&nbsp; The only things<br>
          that really matter to the framework are:<br>
          <br>
          1) That a libtool-constructed module is placed into one of the
          plugin search locations (see previous emails regarding how we
          decide where to look for plugins). The name of the module
          itself is irrelevant (although conventions are in place).<br>
          <br>
          2) That the module defines an externally-visible function:<br>
          <br>
          <span style="font-style: italic;">CollectorImpl*
            CollectorFactor();</span><br>
          <br>
          which creates a CollectorImpl instance for the collector.<br>
          <br>
          Each collector defines a single class (e.g. PCSampCollector or
          UserTimeCollector) that inherits from CollectorImpl (which is
          in the framework source). CollectorImpl declares a bunch of
          pure virtual functions which all<br>
          inheriting classes must implement.&nbsp;&nbsp; So you can
          think of CollectorImpl.hxx as the "API" between the framework
          and the collectors.</blockquote>
      </div>
    </div>
    <br>
    <h2><a class="mozTocH2" name="mozTocId212847"></a>Graphical User
      Interface Plugin Information<br>
    </h2>
    All of the Open|SpeedShop GUI functionality is implemented using the
    GUI plugin mechanisms.&nbsp;&nbsp; To create an Open|SpeedShop GUI
    plugin requires some knowledge about how to use the Qt GUI
    development toolkit.&nbsp;&nbsp; A script is provided to help the
    GUI plugin developer create a basic skeletal Open|SpeedShop Qt
    Panel.&nbsp;&nbsp; The GUI plugin developer then must provide the
    widgets and Qt GUI management routines to display what the plugin
    developer desires.&nbsp;&nbsp;&nbsp; The basic skeletal
    Open|SpeedShop Qt Panel code does provide some code options which
    can be uncommented and modified in hopes of jump starting the
    process of developing additional panels.<br>
    <br>
    Tips on interfacing with the rest of the Open|SpeedShop tool set are
    also provided along with the example code.<br>
    <br>
    <br>
    <h3><a class="mozTocH3" name="mozTocId347900"></a>Graphical User
      Interface (GUI) Plugin Overview<br>
    </h3>
    <h4><a class="mozTocH4" name="mozTocId962438"></a><a
        name="GUI_Plugin_Outline"></a>GUI Plugin Outline</h4>
    What are the high level steps that are required for creating a
    Graphical User Interface Plugin for Open|SpeedShop?&nbsp;&nbsp; This
    outline provides a form of checklist to give the plugin writer an
    overview before delving into the details of developing the plugin.<br>
    <br>
    <ul>
      <li>Think about the data that the plugin needs to display - Can
        this be done with the existing plugins?</li>
      <li>If a GUI plugin is really needed, decide if there is an
        existing GUI plugin or if the Example GUI plugin can be used as
        a model.</li>
      <li>Use the mknewpanel script to create a new directory and
        skeletal panel</li>
      <li>Read the information in this document regarding example code
        and apply it to the new panel if appropriate.</li>
    </ul>
    <a href="#General_OpenSpeedShop_Plugin_Outline">Return to General
      Plugin Section</a>
    <h4><a class="mozTocH4" name="mozTocId117100"></a>GUI Plugin
      Recognition</h4>
    In order for a file to be recognized as a GUI plugin, it must first
    be in the plugin search path.&nbsp;&nbsp; It must be either in the
    default plugin search path or in the path defined by the
    OPENSS_PLUGIN_PATH environment variable.&nbsp;&nbsp; GUI plugins
    must also have the entry point function, panel_init, defined.&nbsp;
    The Open|SpeedShop function "register_plugin" found in
    "libopenss-guiplugin/plugin_handler.cxx" is responsible for checking
    for this entry point.&nbsp; If it is found the GUI plugin is
    registered in the master plugin list.&nbsp;&nbsp; The function
    "initialize_plugins" from the same file as above calls
    "register_plugin".<br>
    <br>
    <h3><a class="mozTocH3" name="mozTocId930728"></a><a
        name="Creating_The_Graphical_User_Interface"></a>Creating A
      Graphical User Interface Panel</h3>
    <h4><a class="mozTocH4" name="mozTocId570308"></a>Initial Skeletal
      Panel Creation - mknewpanel script</h4>
    The "mknewpanel" script creates a basic Open|SpeedShop GUI Panel
    which can then be modified to integrate with the core functionality
    of Open|SpeedShop.&nbsp;&nbsp; This script can be found in the
    subdirectory (from top of tree)
    "plugins/panels/TemplatePanel".&nbsp;&nbsp; A "README" file in that
    same directory gives "mknewpanel" usage information.&nbsp;&nbsp; The
    same information can be obtained by running the "mknewpanel" script
    without any arguments.&nbsp; The script modifies the TemplatePanel
    sources in the TemplatePanel directory and creates a new
    subdirectory under "plugins/panels" using the information given to
    it by the plugin developer running the script.&nbsp;&nbsp; <br>
    <br>
    Here is the example output from the "mknewpanel" script creating a
    Panel named "Test Panel" that will appear under the Performance menu
    in Open|SpeedShop.&nbsp; Note that the initial execution of the
    Linux command "ls" on the "plugins/panels" directory shows no
    directory named "TestPanel".<br>
    $ ls ..<br>
    CmdPanel&nbsp;&nbsp; FPE_TracingPanel&nbsp;
    Makefile&nbsp;&nbsp;&nbsp;&nbsp; ManageProcessesPanel&nbsp;
    mysed&nbsp;&nbsp; StatsPanel<br>
    CustomExperimentPanel&nbsp; HW_CounterPanel&nbsp;&nbsp;
    Makefile.am&nbsp; MPIPanel&nbsp;&nbsp;&nbsp; pcSamplePanel&nbsp;
    TemplatePanel<br>
    DebugPanel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

    IOPanel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Makefile.in&nbsp;
    mvover&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

    SourcePanel&nbsp;&nbsp;&nbsp; UserTimePanel<br>
    <br>
    Now we run the "./mknewpanel" script which creates the TestPanel
    subdirectory in "plugins/panels".<br>
    <br>
    $&nbsp; ./mknewpanel ../TestPanel TestPanel TestPanel "Test Panel"
    "Cntrl B" 1 Performance<br>
    PANEL_DIR=../TestPanel<br>
    PANEL_NAME=TestPanel<br>
    MENU_HEADING=TestPanel<br>
    MENU_LABEL=Test Panel<br>
    MENU_ACCEL=Cntrl B<br>
    SHOW_IMMEDIATE=Performance<br>
    PLUGIN_GROUPING=Performance<br>
    Preparing to create your new TestPanel files.<br>
    Succeeded: Finished creating files in ../TestPanel.<br>
    You'll now need to edit the panels/Makefile.am to add this new
    directory to the build list.<br>
    You'll also need to modify the top level configure.ac file to add
    the new directory to the list of directories to have makefiles
    created.<br>
    <br>
    When we do an "ls" Linux command for the "plugins/panels" directory
    we now see a ""TestPanel subdirectory has been created.<br>
    $ ls ..<br>
    CmdPanel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

    HW_CounterPanel&nbsp;
    Makefile.in&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

    mysed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    TemplatePanel<br>
    CustomExperimentPanel&nbsp;
    IOPanel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    ManageProcessesPanel&nbsp; pcSamplePanel&nbsp; <span
      style="font-weight: bold;">TestPanel</span><br>
    DebugPanel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

    Makefile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    MPIPanel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

    SourcePanel&nbsp;&nbsp;&nbsp; UserTimePanel<br>
    FPE_TracingPanel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Makefile.am&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    mvover&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

    StatsPanel<br>
    <br>
    Doing a list of the files in the "TestPanel" subdirectory, we see
    that the "mknewpanel" script has modified the "TemplatePanel"
    template code and created similar files but renamed "TestPanel".<br>
    <br>
    Once the GUI plugin developer modifies Open|SpeedShop's
    "configure.ac" (both in the top source directory) and "Makefile.am"
    (in plugins/panels directory) files to include the newly created
    panels and rebuilds Open|SpeedShop, the menu item representing the
    panel will be displayed under the menu that the GUI plugin developer
    provided to the mknewpanel script.&nbsp;&nbsp; <br>
    <ul>
      <li>In "configure.ac" add the directory path to the newly created
        GUI plugin anywhere after the list of "plugins/panels/&lt;panel
        name&gt;/Makefile" entries.&nbsp;&nbsp; In this example, add
        "plugins/panels/TestPanel/Makefile". <br>
      </li>
      <li>In "Makefile.am" add the name of the newly created GUI plugin
        panel directory into the "SUBDIRS" list.</li>
    </ul>
    <h4><a class="mozTocH4" name="mozTocId921745"></a><a
        name="The_Panel_Class"></a>The Panel Class</h4>
    The new GUI panel is built off the base class Panel.cxx.&nbsp; The
    Panel base class has several key functions.&nbsp;&nbsp;
    Understanding this base functionality is critical for the GUI plugin
    writer to be successful in creating a GUI plugin that does what the
    writer wants it to.<br>
    <br>
    The key classes to create a panel are: <br>
    <ul>
      <li>The new Panel Constructor</li>
    </ul>
    <div style="margin-left: 40px;">This is typically where the new
      widgets for the panel are created.&nbsp;&nbsp;&nbsp; See the Qt
      documentation for how to create Qt widgets.&nbsp; When using the
      'mknewpanel' script there are several examples of creating Qt
      widgets.&nbsp; See the section <a
        href="#Example_Sections_of_Code">Example Sections of Code</a>.<br>
      <br>
    </div>
    <ul>
      <li>The next two most important member functions are&nbsp; related
        to communication between panels via the "::listener"&nbsp; and
        the "::broadcast" functions.<br>
      </li>
    </ul>
    <ul style="margin-left: 40px;">
      <li>The listener function is used by other panels to communicate
        with this panel. </li>
      <li>The broadcast function is used to communicate with other
        panels. &nbsp;&nbsp; </li>
    </ul>
    <br>
    <div style="margin-left: 40px;">Messages are very simple
      minded.&nbsp;&nbsp; They are message object type with some data
      being passed around.&nbsp;&nbsp; Many examples can be found
      looking in the existing panels.&nbsp;&nbsp; Additionally messages
      can be broadcast to everyone in the tool, a group of panels, or to
      a specific panel. <br>
    </div>
    <br>
    <div style="margin-left: 40px;">An example of creating a message and
      broadcasting it to the group is shown below. It's the message send
      by hitting the "Update" button in any of the baseline experiment
      types. (i.e. pcSamplePanel.cxx <br>
      Here's the snippet of code: <br>
      <br>
    </div>
    <div style="margin-left: 40px;">&nbsp;&nbsp;&nbsp;&nbsp;
      UpdateObject *update_object = new UpdateObject(NULL, expID,
      QString::null, FALSE); <br>
      &nbsp;&nbsp;&nbsp;&nbsp; broadcast((char *)update_object,
      GROUP_T); <br>
    </div>
    <br>
    <div style="margin-left: 40px;">The example above creates an
      UpdateObject() (which is a canned message to tell everyone that
      receives it that they should refresh their view(s).&nbsp;&nbsp; It
      then broadcasts it to everyone with the same group id.&nbsp;
      Similarly this could be sent to every panel by changing the scope
      with: <br>
      <br>
    </div>
    <div style="margin-left: 40px;">&nbsp;&nbsp;&nbsp;&nbsp;
      broadcast((char *)update_object, ALL_T); <br>
    </div>
    <br>
    <div style="margin-left: 40px;">If there's only one other panel your
      new panel is interested in communicating with you can communicate
      directly to its listener routine.&nbsp;&nbsp; The StatsPanel does
      this to a particular source panel. <br>
    </div>
    <br>
    <div style="margin-left: 40px;">If panel writer wants to communicate
      with a specific panel, and your panel doesn't yet have a handle on
      the new panel, it can be queried.&nbsp;&nbsp; (StatsPanel.cxx) <br>
    </div>
    <br>
    <div style="margin-left: 40px;">&nbsp;&nbsp;&nbsp; // First
      construct the name of the panel you're looking for... <br>
      &nbsp;&nbsp;&nbsp; QString name = QString("Source Panel
      [%1]").arg(expID); <br>
      &nbsp;&nbsp;&nbsp; // Now query all panels for that particular
      named panel. <br>
      &nbsp;&nbsp;&nbsp; Panel *sourcePanel =
      getPanelContainer()-&gt;findNamedPanel(getPanelContainer()-.getMasterPC(),
(char
*)name.ascii()

      ); <br>
      &nbsp;&nbsp;&nbsp; // Now you can send information directly to
      that source panel. <br>
      &nbsp;&nbsp;&nbsp; UpdateObject *update_object = new
      UpdateObject(NULL, expID, QString::null, FALSE); <br>
      &nbsp;&nbsp;&nbsp; sourcePanel-&gt;listener( (void *)updateObject
      ); <br>
    </div>
    <br>
    <div style="margin-left: 40px;">The listener on the receiving end
      looks at the message coming in and if it's interested it acts upon
      it and returns TRUE notifying the broadcast routine that someone
      fielded the message.&nbsp;&nbsp; The listener routine should
      return FALSE if it's not interested in the message of for whatever
      reason failed to be able to handle it properly. <br>
    </div>
    <br>
    <ul>
      <li>Another interesting member function is the "::menu"
        callback.&nbsp;&nbsp; This simply overloads the Qt
        contextSensitiveMenu signal to ping your menu routine for
        localize menus that you might want appended to the menu
        list.&nbsp;&nbsp;&nbsp; There are numerous examples of this in
        the panels.&nbsp; See pcSamplePanel::menu for a simple example.
        <br>
      </li>
    </ul>
    <ul>
      <li>There are other more obscurely used functions in
        Panel.[ch]xx.&nbsp;&nbsp; They are not detailed here. </li>
    </ul>
    <h4><a class="mozTocH4" name="mozTocId500145"></a><a
        name="Example_Sections_of_Code"></a>Example Sections of Code</h4>
    The newly created GUI panel code has examples of GUI code that might
    be interesting to an Open|SpeedShop GUI panel writer.<br>
    The following sections describe the different examples and how to
    enable them.<br>
    <br>
    <h5><a class="mozTocH5" name="mozTocId66382"></a>QtClass</h5>
    This code snippet from the newly created "TestPanel.cxx" can be
    enabled and modified to use the GUI panel writer's QtDesigner
    created class.&nbsp;&nbsp; When modified and enabled the GUI panel
    writer will see what they created in QtDesigner in the "TestPanel"
    display.&nbsp;&nbsp;&nbsp; Use "#define QTCLASS" or remove the
    "#ifdef QTCLASS" and "#endif // QTCLASS" to enable this section of
    code.<br>
    <br>
    <small>#include &lt;qlistview.h&gt;&nbsp; // For QListView<br>
      #include &lt;qvaluelist.h&gt;&nbsp; // For QTextEdit in example
      below...<br>
      #include &lt;qsplitter.h&gt;&nbsp; // For QSplitter in example
      below...<br>
      #include &lt;chartform.hxx&gt;&nbsp; // For chart in example
      below...<br>
      TestPanel::TestPanel(PanelContainer *pc, const char *n, void
      *argument) : Panel(pc, n)<br>
      {<br>
      &nbsp; setCaption("TestPanel");<br>
      &nbsp; frameLayout = new QVBoxLayout( getBaseWidgetFrame(), 1, 2,
      getName() );<br>
      <br>
      #ifdef QTCLASS<br>
      // Here's an example of&nbsp; adding a class you created with
      QtDesigner...<br>
      // Defining QtClass (above) will enable this block.<br>
      // This block will include a class that you designed with
      QtDesigner.<br>
      &nbsp; YourClass *ppc = new YourClass(getBaseWidgetFrame(),
      getName() );<br>
      &nbsp; frameLayout-&gt;addWidget( ppc );<br>
      &nbsp; ppc-&gt;show();<br>
      #endif // QTCLASS</small><br>
    <br>
    <h5><a class="mozTocH5" name="mozTocId14581"></a>TopLevel</h5>
    This code snippet from the newly created "TestPanel.cxx" can be
    enabled and modified to create a GUI panel similar to the PCSampling
    and UserTime experiment panels.&nbsp;&nbsp; When modified and
    enabled the GUI panel writer will Run, Pause, Update, and Terminate
    process control buttons created in the "TestPanel"
    display.&nbsp;&nbsp;&nbsp; Use "#define TOPLEVEL" or remove the
    "#ifdef TOPLEVEL" and "#endif // TOPLEVEL" to enable this section of
    code.&nbsp; As the comments in the code say, the GUI panel writer
    can look at existing panels such as the PC Sampling Experiment panel
    in the PCSamplePanel directory.<br>
    <br>
    <small><br>
      #ifdef TOPLEVEL<br>
      // Here's an example of a putting a name toplevel panel container
      in the<br>
      // panel.<br>
      // Defining TOPLEVEL (above) will enable this block.<br>
      // This block will create an outline much like the pcSamplePanel
      and<br>
      // UserTimePanel experiments.<br>
      // A process control panel (run, pause, update, terminate) will be
      created<br>
      // and a panel container to place child panels will be created.<br>
      // See pcSamplePanel for a working example.<br>
      &nbsp; ProcessControlObject *pco = new
      ProcessControlObject(frameLayout, getBaseWidgetFrame(), (Panel
      *)this );<br>
      <br>
      &nbsp; QHBoxLayout *statusLayout = new QHBoxLayout( 0, 10, 0,
      "statusLayout" );<br>
      <br>
      &nbsp; QLabel *statusLabel = new QLabel( getBaseWidgetFrame(),
      "statusLabel");<br>
      &nbsp; statusLayout-&gt;addWidget( statusLabel );<br>
      <br>
      &nbsp; QLineEdit *statusLabelText = new QLineEdit(
      getBaseWidgetFrame(), "statusLabelText");<br>
      &nbsp; statusLabelText-&gt;setReadOnly(TRUE);<br>
      &nbsp; statusLayout-&gt;addWidget( statusLabelText );<br>
      <br>
      &nbsp; frameLayout-&gt;addLayout( statusLayout );<br>
      <br>
      &nbsp; QWidget *namedPanelContainerWidget = new QWidget(
      getBaseWidgetFrame(),<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

      "namedPanelContainerWidget" );<br>
      &nbsp; PanelContainer *topPPL = createPanelContainer(
      namedPanelContainerWidget, "", NULL, pc-&gt;getMasterPCList() );<br>
      &nbsp; frameLayout-&gt;addWidget( namedPanelContainerWidget );<br>
      <br>
      //&nbsp; namedPanelContainerWidget-&gt;show();<br>
      &nbsp; topPPL-&gt;show();<br>
      &nbsp; topPPL-&gt;topLevel = TRUE;<br>
      #endif // TOPLEVEL</small><br>
    <br>
    <br>
    <h3><a class="mozTocH3" name="mozTocId1902"></a>Interfacing With
      Open|SpeedShop - Tips and Example Information</h3>
    <h4><a class="mozTocH5" name="mozTocId784520"></a>Executing a
      command through Command Line Interface (CLI)</h4>
    <span style="font-weight: bold;"></span>The GUI panels use the same
    commands that an interactive user would.&nbsp; The Open|SpeedShop
    tool was designed in this manner to prevent the interactive command
    line interface tool, the batch tool, and the GUI from diverging and
    doing basic functions differently.&nbsp;&nbsp; This makes coding a
    GUI panel slightly more intuitive.&nbsp; If the GUI panel writer
    knows what function they would like the GUI panel to execute, then
    they can look at the interactive command line interface
    documentation and see if that function is covered by an existing
    command.&nbsp;&nbsp; The Command Line Interface document can be
    accessed by clicking <a href="../cli_doc/index.html">here</a>.<br>
    <br>
    This case block taken from the pcSamplePanel.cxx file illustrates
    how CLI commands are passed to the CLI from the GUI.<br>
    <br>
    <small>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case&nbsp; PAUSE_T:<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nprintf( DEBUG_MESSAGES
      ) ("Pause\n");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; command =
      QString("expPause -x %1\n").arg(expID);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int wid =
      getPanelContainer()-&gt;getMainWindow()-&gt;widStr.toInt();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      cli-&gt;runSynchronousCLI(command.ascii());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      statusLabelText-&gt;setText( tr("Process Paused...") );<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret_val = 1;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</small><br>
    <br>
    <h4><a class="mozTocH5" name="mozTocId803177"></a>Communicating with
      other GUI panels</h4>
    See <a href="#The_Panel_Class">The Panel Class</a> section for
    examples.<br>
    <br>
    <h4><a class="mozTocH5" name="mozTocId525403"></a>Managing process
      control</h4>
    Create a new process control object code example from
    "pcSamplePanel:pcSamplePanel" in
    "...../plugins/panels/pcSamplePanel"<br>
    <br>
    &nbsp; <small style="font-style: italic;">frameLayout = new
      QVBoxLayout( getBaseWidgetFrame(), 1, 2, getName() );<br>
      &nbsp; pco = new ProcessControlObject(frameLayout,
      getBaseWidgetFrame(), (Panel *)this );<br>
      &nbsp; runnableFLAG = FALSE;<br>
      &nbsp; pco-&gt;runButton-&gt;setEnabled(FALSE);<br>
      &nbsp; pco-&gt;runButton-&gt;enabledFLAG = FALSE;</small><br>
    <br>
    This code snippet from "pcSamplePanel::listener" in
    pcSamplePanel.cxx gives an example of how Open|SpeedShop manages the
    process control of the experiment/victim application<br>
    <br>
    <small><span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
case&nbsp;

        RUN_T:</span><span style="font-style: italic;"></span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
Put

        out some notification that we're about to run this.</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
Otherwise

        there's a deafning silence between when the user</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
clicks

        the run button and when the run actually begins.</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
This

        gives the user immediate feedback of what's taking place.</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
aboutToRunFLAG
=

        TRUE;</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        pco-&gt;runButton-&gt;setEnabled(FALSE);</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
pco-&gt;runButton-&gt;enabledFLAG
=

        FALSE;</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        pco-&gt;pauseButton-&gt;setEnabled(FALSE);</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
pco-&gt;pauseButton-&gt;enabledFLAG
=

        FALSE;</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        pco-&gt;updateButton-&gt;setEnabled(FALSE);</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
pco-&gt;updateButton-&gt;enabledFLAG
=

        FALSE;</span></small><br>
    <small><span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
command
=

        QString("expGo -x %1\n").arg(expID);</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        {</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int
status

        = -1;</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
nprintf(
DEBUG_MESSAGES

        ) ("Run\n");</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
statusLabelText-&gt;setText(
tr("Process

        running...") );</span><br style="font-style: italic;">
      <br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int
wid

        = getPanelContainer()-&gt;getMainWindow()-&gt;widStr.toInt();</span><span
        style="font-style: italic;"></span><br style="font-style:
        italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        cli-&gt;runSynchronousCLI(command.ascii());</span><br
        style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ret_val
=

        1;</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        }</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        break;</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        case&nbsp; PAUSE_T:</span><br style="font-style: italic;">
      <span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        {</span></small><br>
    <br>
    <br>
    <h3><a class="mozTocH3" name="mozTocId175785"></a><a
        name="Example_Graphical_User_Interface_Plugin"></a>Example
      Graphical User Interface Plugin</h3>
    The example graphical user interface plugin is the plugin that is
    used as the focus of the "mknewpanel" script, the TemplatePanel is
    found in the "&lt;top_srcdir&gt;/plugins/panels/TemplatePanel"
    directory in the Open|SpeedShop source tree.<br>
    <br>
    <h2><a class="mozTocH2" name="mozTocId90403"></a><span
        class="mozTocH2"></span>Interactive Command Line Interface
      Plugin Information</h2>
    tbd<br>
    <h3><a class="mozTocH3" name="mozTocId192580"></a>Interactive
      Command Line Interface (CLI) Plugin Overview</h3>
    tbd<br>
    <br>
    <h4><a class="mozTocH4" name="mozTocId138060"></a><a
        name="Interactive_Command_Line_Interface_CLI__"></a><span
        class="mozTocH4"></span><a
        name="Interactive_Command_Line_Interface_CLI"></a>Interactive
      Command Line Interface (CLI) Plugin Outline</h4>
    tbd<br>
    <br>
    <a href="#General_OpenSpeedShop_Plugin_Outline">Return to General
      Plugin Section</a><br>
    <br>
    <a href="#Top">Top</a><br>
    <br>
    <br>
    <br>
  </body>
</html>
