<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <!--
      Copyright (c) 2006-2011 Krell Institute. All Rights Reserved.
      Permission is granted to copy, distribute and/or modify this document
      under the terms of the GNU Free Documentation License, Version 1.2
      or any later version published by the Free Software Foundation;
      with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
	 Texts.  A copy of the license is included in the section entitled "GNU
      Free Documentation License".
-->
    <meta http-equiv="Content-Type" content="text/html;
      charset=ISO-8859-1">
    <title>Open|SpeedShop Design Overview: Main Page</title>
    <link href="doxygen.css" rel="stylesheet" type="text/css">
  </head>
  <body>
    <!-- Generated by Doxygen 1.3.5 -->
    <div style="text-align: center;" class="qindex"><br>
      <img alt="Open|SpeedShop Logo" src="OpenSpeedShop_Logo.jpg"
        style="width: 303px; height: 38px;"><br>
      <a class="qindexHL" href="index.html"></a><big style="font-weight:
        bold;"><big><big>Design Document</big></big></big></div>
    <big><big><big></big></big></big>
    <div></div>
    <div style="text-align: center;"><big style="font-weight: bold;">Version
2.0.2

        Release<br>
        November 9, 2012</big><br>
    </div>
    <br>
    <h2><a name="mozTocId156671" class="mozTocH2"></a><a class="anchor"
        name="TableOfContents">Table of Content </a></h2>
    <ol id="mozToc">
      <!--mozToc h1 1 h2 2 h3 3 h4 4 h5 5 h6 6-->
      <li><a href="#mozTocId156671">Table of Content </a>
        <ol>
          <li><a href="#mozTocId152427">Introduction</a>
            <ol>
              <li><a href="#mozTocId511853">General </a></li>
              <li><a href="#mozTocId874420">Dyninst and DPCL (not
                  supported as of 1.9 release) </a></li>
              <li><a href="#mozTocId850761">Dyninst and MRNet (Better
                  support as of 2.0.0 release) </a></li>
              <li><a href="#mozTocId334814">Framework </a></li>
              <li><a href="#mozTocId198623">SQLITE </a></li>
              <li><a href="#mozTocId864899">PAPI </a></li>
              <li><a href="#mozTocId824648">Graphical User Interface -
                  GUI </a>
                <ol>
                  <li><a href="#mozTocId770242"> MainWindow - This is
                      where the GUI starts.&nbsp;</a></li>
                  <li><a href="#mozTocId952597"> Panel Containers - A
                      panel container is an area (container) on the
                      screen where panels can be placed and
                      managed.&nbsp;</a></li>
                  <li><a href="#mozTocId540822"> Panels - A panel is
                      where all the nuts-n-bolts knowledge and logic
                      exists for an individual task. &nbsp; &nbsp;</a></li>
                </ol>
              </li>
              <li><a href="#mozTocId455111">Command Line Interface - CLI
                </a></li>
              <li><a href="#mozTocId579981">Open|SpeedShop Scripting API</a></li>
              <li><a href="#mozTocId902967">Open|SpeedShop Invocation
                  Command&nbsp; "openss" </a>
                <ol>
                  <li><a href="#mozTocId970272">openss -gui </a></li>
                  <li><a href="#mozTocId694560">openss -cli:</a></li>
                  <li><a href="#mozTocId436747">openss -batch:</a></li>
                </ol>
              </li>
              <li><a href="#mozTocId282350">Bproc Support</a></li>
            </ol>
          </li>
          <li><a href="#mozTocId286382">API's Defined In Open|SpeedShop
            </a>
            <ol>
              <li><a href="#mozTocId779296">General </a></li>
              <li><a href="#mozTocId927649">API between the
                  Open|SpeedShop Framework component and DPCL</a></li>
              <li><a href="#mozTocId397430">API between the
                  Open|SpeedShop Framework component and MRNet</a></li>
              <li><a href="#mozTocId406405">API between the
                  Open|SpeedShop Framework component and the Experiment
                  Collectors</a></li>
              <li><a href="#mozTocId739245">API between the
                  Open|SpeedShop Framework component and the GUI/CLI
                  tools</a></li>
              <li><a href="#mozTocId155263">API between the
                  Open|SpeedShop Framework component and PAPI</a></li>
              <li><a href="#mozTocId891340">API between the DPCL or
                  MRNet and Dyninst components</a></li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
    <br>
    <h2><a name="mozTocId152427" class="mozTocH2"></a><a class="anchor"
        name="MP_S1">Introduction</a></h2>
    <div style="text-align: left;">
      <h3><a name="mozTocId511853" class="mozTocH3"></a>General<br>
      </h3>
      <span style="font-family: times new roman,times,serif;">Open|SpeedShop
is

        a project to provide open source performance analysis tools for
        a wide range of platforms. The project is designed in such a way
        as to enable value-added plugins for the open source version.
        These value-added plugins can be the pre-canned performance
        analysis experiments, which contain the experiment specific
        collector and the corresponding command line interface and GUI
        support software.&nbsp; There are separate plugins for the
        collector, command line interface, and GUI software
        components.&nbsp; Plugins can also be written for
        advanced/enhanced versions of experiment collectors, command
        line interface and GUI analysis tools. These plugins allow the
        Open|SpeedShop performance tool to be enhanced by the open
        source community.&nbsp;&nbsp; </span><span style="font-family:
        times new roman,times,serif;">Another of the requirements of the
        Open|SpeedShop project is that Open|SpeedShop support
        clustering.&nbsp;&nbsp; The open source component, DPCL, is
        integrated into Open|SpeedShop to provide the clustering
        capability.&nbsp;&nbsp; The use of the Dyninst component allows
        Open|SpeedShop to insert instrumentation and also to attach to
        running processes.&nbsp; See more details in the paragraphs that
        follow.</span><br>
      <br>
      <br>
      <img style="width: 777px; height: 583px;" alt="OSS Internal
        Infrastructure" src="OSS_Internals.png"><br>
      <span style="font-family: times new roman,times,serif;"><br>
        <br style="font-family: times new roman,times,serif;">
      </span><br style="font-family: times new roman,times,serif;">
      <span style="font-family: times new roman,times,serif;"><br>
        The diagram above lists both the existing open source and
        university software as well as the software being developed from
        scratch by SGI under the ASC PathForward procurement.&nbsp; The
        software components in the diagram above are arranged in such a
        way as to show their dependence and interaction with each
        other.&nbsp; For example, the Framework component uses the DPCL
        API to interact with the DPCL component. The Framework also
        interacts with the PAPI component through the </span><span
        style="font-family: times new roman,times,serif;">PAPI
        API.&nbsp;&nbsp; So, one can determine component relationships
        by viewing the diagram.&nbsp; The plugins (GUI panel, CLI, and
        Collector) together define a performance measurement experiment
        definition.&nbsp;&nbsp; This definition along with the
        applications it will be run against create an instance of a
        performance experiment.<br>
      </span>
      <h3><a name="mozTocId874420" class="mozTocH3"></a>Dyninst and DPCL
        (not supported as of 1.9 release)<br>
      </h3>
      <span style="font-family: times new roman,times,serif;"><a
          href="http://www.dyninst.org">Dyninst</a> </span><span
        style="font-family: times new roman,times,serif;">and&nbsp; DPCL
        (</span><a href="http://sourceforge.net/projects/dpcl"
        style="font-family: times new roman,times,serif;">http://sourceforge.net/projects/dpcl</a><span
        style="font-family: times new roman,times,serif;">) are key
        elements of the design.&nbsp; DPCL a component in satisfying the
        clustering requirement.&nbsp; Dyninst allows the Open|SpeedShop
        performance tool to instrument executables to obtain timings and
        also allows the Open|SpeedShop performance tool to attach to
        running processes.<br>
      </span><br style="font-family: times new roman,times,serif;">
      <span style="font-family: times new roman,times,serif;">In a
        clustering configuration DPCL uses a client/server architecture
        where a DPCL "super daemon" is created each time the user starts
        a performance tool.&nbsp; This super daemon is responsible for
        insuring that a "communication daemon" is running on each of the
        machines in the cluster. The super daemon distributes commands
        from the performance tool to the various communication daemons
        and gathers data from them. TCP/IP is the transport mechanism
        for this data in DPCL. Dyninst is used to adding timing, counts,
        or other types of data gathering code to an application. Dyninst
        also intercepts systems calls such as fork() and exec() as well
        as dlopen() calls. This is needed by the tools to follow forking
        processes and to properly handle executables with shared
        objects. Dyninst also provides a certain amount of symbol table
        lookup ability. It supports queries such as "What is the
        function at address XYZ?" </span><br style="font-family: times
        new roman,times,serif;">
      <h3><a class="mozTocH3" name="mozTocId850761"></a>Dyninst and
        MRNet (Better support as of 2.0.0 release)<br>
      </h3>
      <span style="font-family: times new roman,times,serif;"><a
          href="http://www.dyninst.org">Dyninst </a></span><span
        style="font-family: times new roman,times,serif;">and&nbsp; <a
          href="http://www.paradyn.org/mrnet/">MRNet</a>&nbsp;</span><span
        style="font-family: times new roman,times,serif;"> </span><span
        style="font-family: times new roman,times,serif;">are key
        elements of the design.&nbsp; MRNet is the default component in
        satisfying the clustering requirement.&nbsp; Dyninst allows the
        Open|SpeedShop performance tool to instrument executables to
        obtain timings and also allows the Open|SpeedShop performance
        tool to attach to running processes.<br>
      </span><br style="font-family: times new roman,times,serif;">
      <span style="font-family: times new roman,times,serif;"><span
          style="font-weight: bold;">TBD</span></span>
      <h3><a class="mozTocH3" name="mozTocId334814"></a>Framework<br>
      </h3>
      <span style="font-family: times new roman,times,serif;">On top of
        these components, an infrastructure that supports plugins
        (collectors, CLI and GUI support)&nbsp; is built. Collectors are
        data collection components that interface with the
        Open|SpeedShop infrastructure and the operating system in order
        to gather one specific type of performance data. They pass this
        data to the Open|SpeedShop framework runtime which then forwards
        it via the transport mechanisms discussed above to an analysis
        tool (or disk file). In the data analysis, the Open|SpeedShop
        analysis tools plugins would also be needed to analyze the
        performance data that was produced by the collector and produce
        a meaningful view of the data.&nbsp; For example, a MPI
        experiment might have its own collector that was designed to
        gather, say, the amount of time spent in each MPI call. It is a
        plugin, so it would not share code (other than the runtime's
        API) with any other collector. There would also need to be a
        corresponding plugin for the data analysis tool (command line or
        GUI) that knew how to process the gathered data into a
        meaningful view for the user. By separating the data
        gathering/collection plugins from the rest of the Open|SpeedShop
        infrastructure, we gain additional flexibility.</span><br
        style="font-family: times new roman,times,serif;">
      <br style="font-family: times new roman,times,serif;">
      <span style="font-family: times new roman,times,serif;">The design
        include the concept of performance data streaming, in that the
        live data could be viewed on a display as it was gathered. Of
        course this requires that the data is processed by the internal
        routines (analysis plugins) prior to display to the display
        screen. There would also be options to save the streamed data
        for post analysis. The ability to change the experiment being
        run from the GUI interface in "real time" gives the user the
        ability to do some analysis and then react to the results and do
        further analysis without re-running the application. This is the
        advantage of dynamic instrumentation and a reason to use an
        instrumentation package such as Dyninst.&nbsp; </span> For more
      information and for pointers into the Framework design see: <span
        style="font-family: times new roman,times,serif;"><a
          href="Framework/html/index.html">Framework specific design
          documentation.</a><br>
      </span>
      <h3><a name="mozTocId198623" class="mozTocH3"></a><a
          name="sqlite_anchor" class="mozTocH3"></a>SQLITE<br>
      </h3>
      SQLite (<a href="http://www.sqlite.org/">http://www.sqlite.org/</a>)
      is a small C library that implements a self-contained, embeddable,
      zero-configuration SQL database engine.&nbsp;&nbsp;<span
        style="font-family: times new roman,times,serif;"> SQLiteis a
        tool that is used as the Open|SpeedShop </span><span
        style="font-family: times new roman,times,serif;">database
        foundation component.&nbsp; The Framework component of
        Open|SpeedShop uses SQLite in it's Database class as the
        underlying database mechanism for storage of key executable and
        performance experiment data. &nbsp;&nbsp; Find out more by
        examining the Framework's <a
          href="Framework/html/classOpenSpeedShop_1_1Framework_1_1Database.html">Database

          class</a>.</span><br style="font-family: times new
        roman,times,serif;">
      <h3><a name="mozTocId864899" class="mozTocH3"></a>PAPI<br>
      </h3>
      <span style="font-family: times new roman,times,serif;">PAPI (</span><a
        href="http://icl.cs.utk.edu/projects/papi/%29"
        style="font-family: times new roman,times,serif;">http://icl.cs.utk.edu/projects/papi/)</a><span
        style="font-family: times new roman,times,serif;"> is a tool
        that is used as the Open|SpeedShop performance tools interface
        with the hardware counters (HWC). PAPI has been evolving over
        the years from it's start as a Ptools (</span><a
        href="www.ptools.org" style="font-family: times new
        roman,times,serif;">www.ptools.org</a><span style="font-family:
        times new roman,times,serif;">) consortium sponsored project. </span><br
        style="font-family: times new roman,times,serif;">
      <br>
      <h3><a name="mozTocId824648" class="mozTocH3"></a>Graphical User
        Interface - GUI<br>
      </h3>
      <span style="font-family: times new roman,times,serif;">The
        graphical user interface (GUI) code is written using the Qt tool
        kit.&nbsp; </span> The goal of the GUI is to provide an
      intuitive, easy to use, portal to an otherwise complex and
      overwhelming application. &nbsp; In the case of this design we are
      attempting to put an intuitive interface between the user and
      their applications performance experiment. &nbsp; It's a layer
      that will help the user ask the correct questions and get the
      correct meaningful answer back regarding, "Where is my application
      spending all its time and &nbsp;how can I make it go faster."<br>
      <br>
      One objective to this goal is to provide a GUI framework that will
      provide common consistent base functionality. &nbsp; One that will
      prevent a complex set of tools from getting window-itis, yet
      providing the user with all the necessary control and clues/hints
      to achieve their end goal. &nbsp; &nbsp;The GUI base will also
      provide the necessary flexibility to add new functionality as
      other developers begin to develop add-ons (plugins) to improve the
      core set of tools provided.<br>
      <br>
      The GUI is broken into four basic parts. &nbsp; MainWindow, panel
      containers, panels, and api.&nbsp; MainWindow will handle parsing
      command line arguments and initializing plugins. The panel
      containers provide all the underlying metaphors for screen layout,
      menu management, dive functionality, drag-n-drop, communication
      broker, and a high level toolbar. The panels are responsible for
      individual functionality relating to an individual performance
      experiment, source display, file management/lookup, and other
      encapsulated functionality. The panel container functionality is
      responsible for handling communication between the individual
      panels and the framework (when framework functionality is
      required).&nbsp; The API will be responsible for interfacing the
      GUI to the framework.&nbsp;&nbsp; The four GUI base components are
      as follows:<br>
      <ul>
        <li>
          <h4><a name="mozTocId770242" class="mozTocH4"></a> MainWindow
            - This is where the GUI starts.&nbsp;</h4>
        </li>
      </ul>
      <div style="margin-left: 40px;">It's responsible for the tool
        initialization, including splash screen, initial menu bar,
        loading of initial panel container components, initial panel
        components, query of plugin layout and adaptation depending on
        what plugin components are available.&nbsp; <br>
        <br>
        There can be only one MainWindow. </div>
      <ul>
        <li>
          <h4><a name="mozTocId952597" class="mozTocH4"></a> Panel
            Containers - A panel container is an area (container) on the
            screen where panels can be placed and managed.&nbsp;</h4>
        </li>
      </ul>
      <div style="margin-left: 40px;">A panel container can be split
        either horizontally or vertically into 2 panel containers. A
        panel container can contain, one, many, or no panels. A panel
        container has no specific knowledge of what a panel is doing.
        (i.e. It doesn't know anything about experiments. It just
        manages the panels space and any communication with other
        panels.) &nbsp; <br>
      </div>
      <div style="margin-left: 40px;"><br>
      </div>
      <div style="margin-left: 40px;">Each panel container will have a
        simple communication broker to allow panels to communicate.
        &nbsp;<br>
        <br>
        A panel container is responsible for interacting with the user,
        via the panel container menu, to add, delete, resize, or move
        panels. </div>
      <ul>
        <li>
          <h4><a name="mozTocId540822" class="mozTocH4"></a> Panels - A
            panel is where all the nuts-n-bolts knowledge and logic
            exists for an individual task. &nbsp; &nbsp;</h4>
        </li>
      </ul>
      <div style="margin-left: 40px;">It will handle panel specific user
        &nbsp;interaction and interaction with the Framework.<br>
        <br>
        A Panel is placed in a panel container. Each panel is managed by
        the parent panel container. A Panel is the base handle for all
        views. That is each user defined panel (i.e. performance
        experiment type) will have a panel type derived from a base
        class panel. Examples of panel types and their functions would
        be:</div>
      <ul>
        <ul>
          <li>&nbsp;Wizard Panel: The Wizard Panel would be responsible
            for interviewing the user to aid them in selecting the right
            performance tool for the job. &nbsp; After the interview
            process was completed an execute experiment command would be
            passed to the Framework for action. &nbsp;Upon completion
            the user would be notified and an appropriate (default)
            report (Experiment Panel) would be generated for the user.
            &nbsp;</li>
        </ul>
      </ul>
      <div style="margin-left: 80px;"> </div>
      <ul>
        <ul>
          <li>&nbsp;User Time Panel: </li>
          <li>&nbsp;MPI Experiment Panel: </li>
          <li>&nbsp;Call Graph Panel: </li>
          <li>&nbsp;Source Panel </li>
          <li>&nbsp;...</li>
        </ul>
      </ul>
      <div style="margin-left: 40px;">Panels will look like a "tabbed"
        view. A panel can be moved around to be placed near other panels
        for association (communication) to be granted. An example of
        this could be a User Time Panel could be placed near and
        existing Source Panel, so when the user clicks on an object in
        the User Time Panel that relates to a source line, the nearest
        Source Panel would be updated (repositioned) to that source
        line. </div>
      <br>
      Panels will be loaded as plugins. &nbsp;It will be the
      MainWindow's responsibility to locate and configure the GUI to
      interact with whatever plugins are currently located on the
      system. &nbsp; The MainWindow's menus will need to be dynamically
      configured based on the available plugins. &nbsp; A plugin
      directory (directories) will exist with plugin definitions and
      related dynamic libraries to be loaded. &nbsp; The dynamic
      libraries may be loaded initially, or later (on demand), depending
      on their type.&nbsp; Using plugin technology allows for ease of
      extending this tool in the future. &nbsp; It also will keep this
      tool very lightweight as only the functionality requested needs to
      be loaded.<br>
      <br>
      For more information and for pointers into the GUI design see: <a
        href="GUI_overview.html">GUI Overview</a> <br>
      <h3><a name="mozTocId455111" class="mozTocH3"></a>Command Line
        Interface - CLI<br>
      </h3>
      The interactive command line (CLI) tool uses a plugin facility,
      similar to that of the GUI, to define it's experiment specific
      functionality.&nbsp; One of the CLI component responsibilities is
      to locate and configure the CLI to interact with whatever plugins
      are currently located on the system.&nbsp; <br>
      <br>
      A set of interactive CLI commands allow the creation of a
      performance measurement experiment, the ability to control the
      experiment enabled target application, the ability to view the
      performance measurement output values, and other supporting
      actions.&nbsp; The interactive CLI commands and their
      corresponding syntax is defined in the <small><small><small><b><font
                face="Courier New" size="5"><small><small><a
                      href="../cli_doc/index.html">Open/SpeedShop
                      Command Line Definitions</a> </small></small></font></b><font
              face="Courier New" size="5"><small><small>document.</small></small></font></small></small></small><br>
      <small><small><small><font face="Courier New" size="5"><small><small><br>
                  The major design sections of the CLI tool are the
                  parser, the command processing semantic routines, the
                  Python bridge, and the command object interface.</small></small></font></small></small></small>&nbsp;

      To view the current design documentation for the CLI tool, see <a
        href="CLI/html/index.html">CLI design.</a><br>
      <h3><a name="mozTocId579981" class="mozTocH3"></a><a
          name="Scripting_API" class="mozTocH3"></a>Open|SpeedShop
        Scripting API</h3>
      There will be a scripting functionality built into the CLI
      tool.&nbsp; We will use Python as the scripting language.&nbsp;
      Analysis was done and Open|SpeedShop commands will not be used in
      the Python scripting API.&nbsp;&nbsp;&nbsp;&nbsp; Collaborative
      definition on the scripting API was agreed upon during Milestone
      4.&nbsp;&nbsp;&nbsp; See the Python scripting API documentation
      found at this <a href="../pyscripting_doc/index.html">link</a>.<br>
      <h3><a name="mozTocId902967" class="mozTocH3"></a><a
          name="OpenSpeedShop_Command_Definition" class="mozTocH3"></a>Open|SpeedShop
Invocation
Command&nbsp;

        "openss"<br>
      </h3>
      The Open|SpeedShop program will be invoked by the user typing the
      "openss" command.&nbsp; When the user invokes Open|SpeedShop
      command there are three options for it's mode of operation:<br>
      <ul>
        <li>
          <h4><a name="mozTocId970272" class="mozTocH4"></a><span
              style="font-weight: bold;">openss -gui</span> </h4>
        </li>
      </ul>
      <div style="margin-left: 40px;">This invocation of Open|SpeedShop
        causes the GUI to be raised then a command panel is also
        created.&nbsp; This command panel window becomes the interactive
        CLI window.&nbsp; Under this invocation Open|SpeedShop
        interactive commands can be entered into the GUI's command panel
        and have the same effect as if they were entered under the
        "openss -cli"
option.file:///usr/people/jeg/openss/current/doc/cli_doc/command_definition.html</div>
      <ul>
        <li>
          <h4><a name="mozTocId694560" class="mozTocH4"></a><span
              style="font-weight: bold;">openss -cli</span>:</h4>
        </li>
      </ul>
      <div style="margin-left: 40px;">This invocation of Open|SpeedShop
        causes the window terminal becomes the interactive CLI
        window.&nbsp;&nbsp; </div>
      <ul>
        <li>
          <h4><a name="mozTocId436747" class="mozTocH4"></a><span
              style="font-weight: bold;">openss -batch</span>:</h4>
        </li>
      </ul>
      <div style="margin-left: 40px;">This invocation of Open|SpeedShop
        causes Open|SpeedShop to execute a performance experiment.
        specified by additional arguments, directly without user
        interaction.&nbsp;&nbsp; The -batch operation can be used in
        scripts and batch processing environments.<br>
      </div>
      <br>
      The CLI interactive commands that can be entered in either the GUI
      Command Panel or the CLI window are defined in the <small><small><small><font
              face="Courier New" size="5"><small><small><a
href="file:///usr/people/jeg/openss/current/doc/cli_doc/command_definition.html">Open/SpeedShop
Command
Line

                    Definitions</a> </small></small></font><font
              face="Courier New" size="5"><small><small>document.&nbsp;
                  This document also contains general usage scenarios to
                  aid in successful usage of the commands.</small></small></font></small></small></small><br>
      <small><small><small><font face="Courier New" size="5"><small><small><br>
                </small></small></font></small></small></small>
      <h3><a name="mozTocId282350" class="mozTocH3"></a>Bproc Support</h3>
      Open|SpeedShop will function on Open|SpeedShop supported Linux
      systems that are running the <span style="font-family: times new
        roman,times,serif;"><a
          href="http://sourceforge.net/projects/bproc">Bproc</a> (</span>Beowulf
Distributed

      Process Space) kernel modifications.&nbsp; The Dyninst component
      is the where the Open|SpeedShop tool interfaces with the Bproc
      functionality. &nbsp; Support for clusters using a single system
      image (the BProc model) is provided.&nbsp;&nbsp; The design is to
      run in the same fashion as on other machines, e.g. a DPCL daemon
      on all the nodes of the machine&nbsp;&nbsp; Dyninst was found,
      with minor modifications, to be capable of manipulating remote
      processes in a BProc-based cluster.&nbsp; <br>
      <br>
      <h2><a name="mozTocId286382" class="mozTocH2"></a><a
          class="anchor" name="MP_S1">API's Defined In Open|SpeedShop <br>
        </a></h2>
      <h3><a name="mozTocId779296" class="mozTocH3"></a><a
          class="anchor" name="MP_S1">General<br>
        </a></h3>
      There are several API's defined in the Open|SpeedShop
      product.&nbsp; First a bullet list is provided, then the sections
      that follow will provide more detail as to the reasons for each
      API's existence.&nbsp;&nbsp; The major API's in Open|SpeedShop are
      as follows:<br>
      <ul>
        <li>API between the Open|SpeedShop Framework component and DPCL
        </li>
        <li>API between the Open|SpeedShop Framework component and MRNet<br>
        </li>
        <li>API between the Open|SpeedShop Framework component and the
          Experiment Collectors</li>
        <li>API between the Open|SpeedShop Framework component and the
          GUI/CLI tools<br>
        </li>
        <li>API between the Open|SpeedShop Framework component and PAPI</li>
        <li>API between the DPCL and Dyninst components<br>
        </li>
      </ul>
      <h3><a name="mozTocId927649" class="mozTocH3"></a>API between the
        Open|SpeedShop Framework component and DPCL</h3>
      The API between the Open|SpeedShop Framework component and DPCL is
      the standard DPCL API defined by the <a
        href="http://dpcl.sourceforge.net/doc/dpclref/dpclref.html">DPCL
        Class Reference document</a>.&nbsp;&nbsp; Open|SpeedShop uses
      this previously defined API to support clustering performance
      measurement collection and analysis.&nbsp; The use of this API is
      driven by requests from the API between the Framework component
      and the GUI/CLI tools.<br>
      <br>
      <h3><a class="mozTocH3" name="mozTocId397430"></a>API between the
        Open|SpeedShop Framework component and MRNet</h3>
      The API between the Open|SpeedShop Framework component and MRNet
      is the MRNet API. &nbsp; Open|SpeedShop uses this previously
      defined API to support clustering performance measurement
      collection and analysis.&nbsp; The use of this API is driven by
      requests from the API between the Framework component and the
      GUI/CLI tools.<br>
      <br>
      <h3><a name="mozTocId406405" class="mozTocH3"></a>API between the
        Open|SpeedShop Framework component and the Experiment Collectors</h3>
      The API between the Open|SpeedShop Framework component and the
      specific experiment collector modules is the API that allows the
      experiment developer to create a collector.&nbsp; This collector
      module will gather performance data from the application by
      specifying a metric or metrics to be collected.&nbsp; If you are
      writing a new performance data collector plugin, start with the
      page <a class="el" href="Framework/html/group__CollectorAPI.html">
        Collector Plugin API</a>.<br>
      <h3><a name="mozTocId739245" class="mozTocH3"></a>API between the
        Open|SpeedShop Framework component and the GUI/CLI tools</h3>
      The API between the Open|SpeedShop Framework component and the
      GUI/CLI tools is called the Performance Tool API.&nbsp; It is the
      API that allows the tool developer to control the application
      execution, enable and disable performance data collection, create
      thread groups, and other tasks related to controlling the
      gathering and execution of the application or applications.&nbsp;
      If you are writing an application performance tool that will use
      the framework, the best place to start is with the page <a
        class="el" href="Framework/html/group__ToolAPI.html">
        Performance Tool API</a>.<br>
      <h3><a name="mozTocId155263" class="mozTocH3"></a>API between the
        Open|SpeedShop Framework component and PAPI</h3>
      The API between the Open|SpeedShop Framework component and PAPI
      .......<br>
      <h3><a name="mozTocId891340" class="mozTocH3"></a>API between the
        DPCL or MRNet and Dyninst components</h3>
      The API between the DPCL or MRNet and Dyninst components is the
      standard Dyninst API defined by the&nbsp;<a
        href="http://www.paradyn.org/html/manuals.html">Dyninst API
        document</a>.<br>
      <br>
      <br>
    </div>
    <br>
    <p><br>
    </p>
  </body>
</html>
